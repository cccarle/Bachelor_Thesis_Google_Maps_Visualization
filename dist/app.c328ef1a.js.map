{"version":3,"sources":["../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js","../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","node_modules/dotenv/lib/main.js","node_modules/load-google-maps-api/index.js","convec_hull.js","node_modules/quickselect/quickselect.js","node_modules/rbush/index.js","node_modules/two-product/two-product.js","node_modules/robust-sum/robust-sum.js","node_modules/two-sum/two-sum.js","node_modules/robust-scale/robust-scale.js","node_modules/robust-subtract/robust-diff.js","node_modules/robust-orientation/orientation.js","node_modules/monotone-convex-hull-2d/index.js","node_modules/tinyqueue/index.js","node_modules/point-in-polygon/index.js","node_modules/concaveman/index.js","calculatePolygons.js","app.js"],"names":["process","module","exports","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","setTimeout","e","clearTimeout","runTimeout","fun","call","runClearTimeout","marker","queue","draining","currentQueue","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","nextTick","args","Array","arguments","i","push","Item","array","prototype","apply","title","env","argv","version","versions","noop","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","fs","require","path","log","message","console","NEWLINE","RE_INI_KEY_VAL","RE_NEWLINES","NEWLINES_MATCH","parse","src","options","debug","Boolean","obj","toString","split","forEach","line","idx","keyValueArr","match","key","val","end","isDoubleQuoted","isSingleQuoted","substring","replace","trim","config","dotenvPath","resolve","encoding","parsed","readFileSync","Object","keys","hasOwnProperty","error","convexhull","makeHull","points","newPoints","slice","sort","POINT_COMPARATOR","makeHullPresorted","upperHull","p","q","r","x","y","pop","lowerHull","a","b","concaveman","splitByTimestamp","coordinates","coordinatesByTime","c","time","Date","timestamp","h","getHours","timeName","measure","coord1","coord2","lat1","lat","lon1","lng","lat2","lon2","R","dLat","Math","PI","dLon","sin","cos","atan2","sqrt","d","coordinateIsIn","coordinate","coordinateGroups","index","polygon","includes","groupCoordinatesByDistance","allowedDistance","iPolygonIndex","j","distance","location","jPolygonIndex","newArr","splice","getCoordinatesInXY","coordinatesXY","getXYCoordinatesInLatLng","coordinatesLatLng","calculatePolygon","polygonXY","polygonLatLng","calculatePolygonsFromCoordinateGroups","polygons","group","getPolygon","newCoordinates","JSON","stringify","groups","loadGoogleMapsApi","cords_full","one_coordinates","dataset_1","searchRadiusButton","document","getElementById","arr","map","googleMaps","heatmap","radius","covertToGoogleMapsCords","data","cord","window","google","maps","LatLng","weight","initMap","_initMap","addEventListener","mapElement","libraries","then","Map","center","zoom","zoomControl","scaleControl","scrollwheel","disableDoubleClickZoom","mapTypeId","createPolygonLayer","copyOfDataSet","colorizedDataset","divideColorToCordordinates","createCircelsLayer","createHeatmapLayer","calculateWeight","writePositionsToJSONByClick","stdCoordinates","crds","diff","element","percent","parseFloat","toFixed","creatPolygon","sColor","sOpacity","fColor","fOpacity","polygonLayer","Polygon","paths","strokeColor","strokeOpacity","strokeWeight","fillColor","fillOpacity","draggable","allCords","cordsArray","setMap","visualization","HeatmapLayer","set","get","gradient","dividedArray","splitToChunks","color","parts","result","ceil","coord","coordCircle","Circle","changeRadius","inputValue","querySelector","value","event","latLng","now"],"mappings":"AiBAA,AbAA,AYAA,AbAA,AUAA,AEAA,ATAA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,IQAMoG,UAAU,GAAGxC,OAAO,CAAC,eAAD,CAA1B;AhBAA,ADAA,AgBCA,AdAA,ACAA,AUAA,AEAA,ATAA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA;ARAA,ADAA,AiBAA,ADCA,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,ITDI5D,AiBAEsH,OjBAK,GAAGrH,AiBAE,GAAG2D,GjBAC,CAAC1D,GiBAK,CAAC,GjBAb,GAAiB,EAA/B,EAEA,EiBF0B,CAA1B;AhBCA,ADEA,AgBDA,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA;ARAA,ADEA,AiBDA,ADAA,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,SQASqH,gBAAT,CAA0BC,WAA1B,EAAuC;AhBAvC,ADEA,AiBDI,ADAJ,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,MQAQC,iBAAiB,GAAG,EAAxB;AhBAJ,AgBCID,ADAJ,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,EQAIA,WAAW,CAAC3C,OAAZ,CAAoB,UAAA6C,CAAC,EAAI;AhBA7B,ADEA,AiBDQ,ADAR,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,ITCIvH,IiBDQwH,IAAI,GAAG,IAAIC,CjBCvB,GiBDmB,CAASF,CAAC,CAACG,SAAX,CAAX;AhBAR,ADEA,AiBDQ,ADAR,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,ITCIzH,IiBDQ0H,CAAC,GAAGH,IAAI,CAACI,KjBCrB,GiBDgB,EAAR;AhBAR,AgBCQ,ADAR,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,QQAYC,QAAQ,GAAGF,CAAC,CAACnD,QAAF,KAAe,MAAf,GAAwBmD,CAAC,CAACnD,QAAF,EAAxB,GAAuC,KAAtD;AhBAR,ADEA,AgBDA,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,STCStE,gBAAT,GAA4B;ACD5B,ADEI,AiBFI,ADCR,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,QTCU,AiBFE,CAACoH,GjBECnH,KAAJ,CAAU,QiBFU,CAAC0H,QAAD,CAAtB,EAAkC,ajBEhC,CAAN;ACDJ,ADEC,AkBbDpE,ADWY6D,ADCZ,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,MQDYA,CCXL,CAAC,QAAD,CAAP,CAAkB/B,KDWW,CCX7B,ADW8BsC,QAAD,CAAjB,GAA8B,EAA9B;AhBCZ,AgBAS,ADCT,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA;ARAA,ADCA,AkBbA,AFaA,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,ISbMkD,KlBaG3K,YkBbc,GAAGqD,IlBa1B,GAAgC,AkBbC,CAAC,sBAAD,CAAjC;AjBaA,ADCI,AiBFI6D,ADER,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,IQFQA,IjBEE,IAAInH,KAAJ,CAAU,GiBFK,CAAC0H,QAAD,CAAjB,CAA4BhG,IAA5B,CAAiC0F,CAAjC,ejBEE,CAAN;ACAJ,ADCC,AkBdD,ADYK,ADEL,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,GQVI,CCJA/D,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAhB;AjBcA,AgBDI,ADEJ,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,SUFW6D,iBAAP;AhBEJ,ADAC,AkBdD,ADaC,ADED,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWfIkD,QAAQ,ClBcC,EkBdE/G,OAAO,CAAC,qBAAD,CAAtB;AjBeA,ADAI,AgBCJ,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,MPDQ;ACCR,ADAQ,AkBdR,ADaA,AbGA,AYDA,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWfIuH,IlBcQ,CiBDHlD,KCbK,ClBcKzH,CiBDnB,CAAiB0H,MAAjB,EjBCY,AiBDaC,KjBCS,CiBDlC,EAAiC,OjBCzB,EAAsC,y8rEkBd9C;AjBeA,ADAYhI,AkBdZ,ADYoC,ADGpC,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWfIiL,ElBcQjL,akBdO,GlBcS,GAAGK,UAAnB,wJkBdZ;AjBeA,ADAS,AkBbT,ADWI,AbKJ,AYFA,AdCA,ACDA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWdI6K,AdgBAjF,AFDEzC,CFJE,CiBAAyE,AfIA,GAAGxE,CeJC,CjBEG,EkBbF,ADWEsE,CbKD,EchBE6C,AhBeE,CECD,AFDE,EeJE,CCXD,ADWE1C,CCXDhE,AdgBA,AFDH,CAAlB,CeJI,GCXY,CAAW8G,MdgBM,IchBjB,CAAhB;AjBcA,ADAYhL,AkBbZ,ADWI,AbMA,AYHJ,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWdImL,ElBaQnL,AiBFJmI,IAAI,GAAGJ,MAAM,CAACK,EjBEM,AkBbN,CDWlB,EjBE2BlI,AkBbNkL,QAAQ,CAACC,OlBatB,OkBba,CAAwB,cAAxB,CAAzB;AjBcA,ADAS,AkBbT,ADWI,AbMA,AYHJ,AdAA,ACAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWdIC,AhBcE5H,EeHE2E,CCXD,ChBcG,EgBdA,ADWE,CfGC5E,CgBdb,CDWeuE,KfGK,CeHC,AfGA,CeHCE,GAAlB,EfGgB,CAApB;ADAA,ADAK,AkBbL,ADWI,AbMA,AYHJ,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,GPPI,CAME,AkBbFqD,EDWIjD,CCXR,EAASkD,CDWG,CjBEClL,CAAP,CiBFS0H,CjBEC,KkBbhB,ADWqB,CAACI,CCXDqD,EDWjB,KCXJ;AjBcA,ADAQzL,AkBbR,ADYI,AbKA,AYHJ,AdAA,ACAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IPDQA,AkBbJ0L,EDYInD,CAAC,AbKArC,EFHAvC,CgBdC,ADYE,EfEZ,CgBda,AhBcCC,EgBdd,AdiBI,EcbJ,CDQI,AbKgB,CaXa,CjBOT,AiBDF,GjBCK1D,KIIGiG,MAAV,EAAkB,GJJ9B;ACCR,ADAK,AIIG,AYHR,AdDsB,ACCtB,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,QHGYC,SAAS,GAAGD,MAAM,CAACE,KAAP,EAAhB;AHHR,AiBRA,ADMI,AbMID,AYHR,AdFA,ACEA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,ELFqC,EgBP/BuF,AdYEvF,EaNAoC,IAAI,GAAGH,AbME,CAAC/B,GaNC,CbMX,CAAe,CaNDmC,IAAI,AbMElC,CaNDmC,ECNE,ADMd,GCNiB,ADMA,GAAjB,GAAuBT,GCNhC0D,CDMoC,AbMlC,GaNqClD,IAAI,CAACC,EAAZ,GAAiB,GAAnD,MCN4B,CAACkD,IAAD,EAAU;AjBS1C,ADDI,AkBPF,ADME,AbMI,AYHR,AdFE/H,ACEF,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,ELFEA,IFAM,AiBDA8E,GCNCiD,AhBOA,CeDG,AfCFjI,CEKK,EcZF,ADME2E,AfCb,CgBPYiD,EdYM/E,CcZX,ADMU,CCND,EDMIiC,IAAI,CAACC,EAAZ,CCNImD,EDMa,ECNd,CDMH,AbMA,CcZa,AdYUzF,EaNA+B,IAAI,AfCTvE,GeDY6E,AbM9B,CAAP,GaNyC,AfC/C,CeDgDC,EAAZ,GAAiB,GAAnD;AhBGJ,ADDQ,AkBPJ,ADMA,AbMC,AYHL,AdFC,ACED,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,GHDI,CAL6B,CAY7B,CaTIzB,CAAC,CjBCG,EiBDAwB,CCND,GDMK,CjBCGlI,AiBDFqI,GAAL,CAASJ,IAAI,GAAG,CjBChB,AiBDA,IAAqBC,CjBCG,GiBDC,CAACG,GAAL,CAASJ,EjBClC,EAAwC,AiBDF,GAAG,CAAhB,CAArB,GACJC,IAAI,CAACI,GAAL,CAASZ,IAAI,GAAGQ,IAAI,CAACC,EAAZ,GAAiB,GAA1B,IAAiCD,IAAI,CAACI,GAAL,CAASR,IAAI,GAAGI,IAAI,CAACC,EAAZ,GAAiB,GAA1B,CAAjC,GACAD,IAAI,CAACG,GAAL,CAASD,IAAI,GAAG,CAAhB,CADA,GACqBF,IAAI,CAACG,GAAL,CAASD,IAAI,GAAG,CAAhB,CAFzB;AhBGJ,ADDY1I,AkBPN2J,ADQF,ADCJ,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,MPFY3J,AkBPN2J,ADQErC,CAAC,GAAG,ICRE,ADQEkB,ECRA,EDQI,CAACK,CCRDgD,IlBOU,AiBCd,CAAWrD,CCRD,ClBOOlI,AkBPNwL,EDQI,CAAChD,GCRZ,CAAciD,ADQP,CAAU/E,CAAV,CAAX,CCRI,ClBOR,AkBP2BgF,ADQExD,IAAI,CAACM,CCR9B,CAA8B,EDQL,CAAU,IAAI9B,CAAd,CAAzB,CAAZ;AhBCJ,ADDS,AkBPDiB,ADQJ,ADCJ,AdFA,ACEA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,ILFMpE,CFFE,CiBGAkF,CAAC,CCRDd,EDQIK,CjBDG,AkBPJ,ADQE,AfDA,EgBPAsD,CDQGtE,AfDA,CeCZ,ECRa,CAACqC,AhBOlB,QgBPa,CAAc1B,GADmB;AjBU9C,ADDYjI,AkBPJmI,ADQJ,AbKA,AYJJ,AdFA,ACEA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,IZFMrE,EFAM9D,CIMHuG,CcbD4B,CDQGY,CAAC,CCRD,EAAE6C,ADQE,ICRE,ADQb,CCRcjC,ADNe,Afab,CeCC,EfDE,GFAO,AIM1B,EcbS,ClBOoBxJ,AkBPNgI,AdaE,UAAUjC,MAAV,EAAkB,CJNnC,MEAZ;ADEA,ADDS,AkBVqC,ADW7C,AbKO,AYJR,AdFA,ACEA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,IZFMnC,GgBVU,CADL,AdiBCmC,MAAM,CAACjF,AFNF,GAAG,GEMR,GFNZ,CEM6B,CAArB,EACI,OAAOiF,MAAM,CAACE,KAAP,EAAP,CAFmC,CAIvC;AHPR,ADDK,AkBPC6F,AdgBE,AYPR,AdFA,ACEA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,GdRI,CAME,AEAAjI,EgBPAiI,KlBOO5L,CAAP,AkBPM,ElBOI,AkBPFuL,IAAI,AhBOE,CgBPDK,EhBOI,YAAvB,EAEA;ADAA,ADDQjM,AkBbG,ADgBX,AbMQ,AYPR,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,IdFQA,CkBbJ,IDgBKgJ,ajBHiB,CiBG1B,CAAwBC,CjBHK9I,SiBG7B,EAAoC+I,QjBH5B,QiBGR,EAAsD;AhBDtD,ADDK,AkBPF,ADUC,ADDJ,AdDA,ACCA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,GIjBS,CAAP,EDkBMC,GfFClF,EeEI,GAAG,AfFhB,CeEiB,AfFDC,CeEZ;AhBDJ,ADDC,AkBPA,ADUGgF,AbMI,AYPR,AdFoB,ACEpB,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,CdrBC,AkBED,CDoBIA,EjBtBJ,II4BY1C,SAAS,CaND,CAAC/B,CbMG,EAAhB,IaNJ,CAAyB,UAAC2E,OAAD,EAAUzH,CAAV,EAAgB;AhBD7C,AiBPA,ADSQ,ADDR,AdHA,ACGA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,EZH4CwC,MeIhCiF,OAAO,CAACC,QAAR,CAAiBJ,UAAjB,CAAJ,EAAkC;AhBD1C,ADFA,AiBIYE,AbKJ,AYNR,AdJoD,ACIpD,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,MGCYA,GjBJH5I,AISI,EaLI,EbKAoB,CaLGA,AbKF,CaLN,EbKS,CAAb,CJTR,CAAoBnB,AISImB,CAAC,EJTzB,CIS4BuE,CJTH,KISS,CAACjF,MAA3B,EAAmCU,CAAC,EAApC,EAAwC;AHNhD,ADFI,AiBIQ,AbKA,AYNZ,AdLA,ACKA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,MdHQ5B,IISQ0G,CAAC,GAAGP,MAAM,CAACvE,CJTH,AISE,CAAd,IJTiBvB,UAAzB,EAAqC;ACGzC,ADFQ,AiBIC,ADDT,AdNgF,ACMhF,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA;AbAA,ADFQ,AiBIH,AbIO,AYLZ,AdPyG,ACOzG,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,GGJI,QjBCWA,EIQIoG,QJRM,CAAChG,AIQE,CAACS,EJRJ,EAAM,CAAN,CAAjB,AIQW,IAAoB,CAA3B,EAA8B;AHL1C,ADFK,AiBID,AbIY,AYLhB,AdPE,ACOF,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,GdPyB,CAKrB,EELImD,GeQG+E,EfRE,CEYOzC,CAAC,CaJjB,AfRYrC,EEYQmC,KFZD,CAACrC,GEYS,CAACqC,GFZH,IAAIrC,EEYQ,CAAClD,IFZF,CAACmD,CEYT,GAAmB,CAApB,AFZV,CEYP,AFZd;ADOF,AiBRA,ADUC,AbIe,AYLhB,AdPE,AWOF,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,IITM8H,EhBEE5H,GAAG,EgBFE,CdcOqC,AFZN,CEYO,CcdL,AhBEd,CAFuG,CEcjFH,AFVtB,OgBJuB2F,EdcQ,CAAC3F,KcdlB,GAAoB,CdcO,CAACvF,MAAV,GAAmB,CAApB,CAAjB;AHLhB,AiBREkK,Adcc,AYLhB,AHAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,EITEA,QAAQ,CAACiB,CdcS,CAAC1F,CAAC,CAACE,CAAF,GAAMD,CAAC,CAACC,CAAT,KcdlB,AdciCH,CcdP,AdcQ,CAACI,CAAF,GAAMF,CAAC,CAACE,CAAvB,KAA6B,CAACH,CAAC,CAACG,CAAF,CcdhD,EAA8C,AdcQF,CAAC,CAACE,CAAT,KAAeJ,CAAC,CAACG,CAAF,CcdV,EdcgBD,CAAC,CAACC,CAAvB,CAAjC,EACIJ,SAAS,CAACM,GAAV,GADJ,KAGI;AHRpB,ADHI,AkBLA,ADUJ,AbOa,AYRb,AdNE5C,AWMF,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,EZNEA,GAAG,CFEG,AEFFK,CFEGxE,CkBLDsM,CDUC/C,KfPP,GAAe9E,CgBHC,GAAG2G,ChBGnB,CFEuB,AEFFnH,KFEO/D,CkBLD,CAACmL,KDU9B,CAAoChE,CfPlC,EAAqC3C,KFE9B,AkBLY,CAAwB,ChBG3C,CeOF,AfP+C,CFEG,CAAC1E,AiBKFwJ,CCV5B,CAAjB,MhBGqD7E,IAAV,EAAgBC,CeO/D,CjBLQ,CiBK0D,AfPnB,EAAqB,EFEIvE,UAApE,EAAgF;ACIpF,ADHQL,AkBJJ+K,ADSA,ADDJ,AdNI,AWMJ,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,IdJQ/K,AkBJJ+K,EDSI5B,cjBLgB,CkBJH,CAAC,ADSE,CjBLG9I,EiBKA,EAAvB,MjBLI;ACIR,ADHQ,AkBJF0E,AdeM0B,AYPZ,AdNI,AWMJ,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,MIRM1B,AdeM0B,EFbF5B,CgBFD,ElBIMxE,IIWM,CAACwB,GFbD,CEaT,CJXa,AIWE6E,CJXDjG,AIWd,AFbYkE,GFEC,CEFG,CFEG,AEFFG,CFEJ,CAAjB,GEFgB,CAAWf,cAAX,CAApB,CAFgE,CAGhE,EgBJkB;AjBStB,ADHK,AkBJCwI,ADQF,AbOK,AYPT,AHAA,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,MIRMA,CDQG,IAAI3K,CAAC,GCRC,ADQE,CAAb,CCRa,CAAC,ADQEA,CAAC,GAAGyF,WCRP,ADQkB,CAACnG,MAAhC,EAAwCU,CAAC,EAAzC,EAA6C;AhBAjD,AiBVsB,ADWd,ADAR,AdNI,AWMJ,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,KIXqB,CAAjB,CAGG4K,CDQKjF,AfNJ1C,CeMK,ECXT,CAGQ,ADQIwC,OfNG,GgBFN0E,CDQL,AfNe,IAAnB,CgBFQ,ChBEiB,CgBFL;AjBQxB,ADJI,AkBHEP,ADQE,AbMA/E,AYNR,AdNM,AWMN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,IVMQA,EJXA,AkBHF+E,EDQM/B,EfNA1E,GEYK,AFZF,CEYGgC,EcdF,AhBEElC,CEYV,EcdWkH,EDQM,GAAG9C,CCRtB,EhBEuB,CAAC,CAAD,CAAvB,CADuB,CAEvB,MeKoC,CAAC1B,CAAC,CAAC3F,CAAD,CAAF,EAAOuH,gBAAP,CAAlC;AhBAR,ADJQ,AkBFFoC,AdcE,AYPR,AHAA,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,MIPMA,EdcMvE,CcdH,GAAG,IAAIwE,CdcK,GAAG,EAAhB,IcdkB,CAACiB,GAAf,CAAmBH,UAAnB,EAA+B;AjBO3C,ADJQ,AkBFAI,ADMA,ADCR,AdNM,AWMN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIPQA,ADMIjD,EfLFzE,CFCKhF,EEDF,CgBDC,EAAE,AhBCC6E,KeKQ,GAAG,CAApB,EjBJuB,AiBIA,AfLH,CFCIpE,AEDH,CAAD,CAAX,CFCc,EAAM,CAAN,AEDI,CFC3B,CEDF;ADMN,ADJK,AkBFKyH,ADMEiB,AbOJ,AYNR,AdNM,AWMN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,GdRI,CAGE,EiBIMA,GbOC,CcbHjB,AhBCEjD,CFCA3E,CAAN,CkBFO,AdaIsB,AFZF,CFCD,AIWI,CcbH,ChBCGoD,CEYGmB,EFZA,CAACjF,EeKM,CAACW,AbOF,CAACX,EFZV,CeKN,CAAsB,CAACqG,AfLJ,CeKK,AbOf,AFZf,CeK+B3F,CAAD,CCPpB,ADOkB,AbOG,CaPzB,AbOJ,EAAgCA,CAAC,IAAI,CAArC,EAAwCA,CAAC,EAAzC,EAA6C;AHNrD,ADJQ,AkBFEwG,ADMEqB,AbOA,AYNZ,AdNM,AWMN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,MGDYA,EjBJA,EkBFFrB,AdaM1B,AFZJxB,CEYK,EcbJ,CdaOiB,CcbL,IDMU,CbOC,CAACvE,CaPCuH,AbOF,CAAd,CFZc,GAAGnE,GAAG,CAAC,CAAD,CAAH,KeKe,AfLJ,CeKK9D,EfLhB,IeKD,AfLmB8D,GeKO,AfLJ,CeKtC,AfLuCC,GAAD,CAAH,KAAa,GAAtD;ADMN,ADJY,AkBLI,ADSP,ADCT,AdNM,AWMN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,SIX2C,ChBK/BE,cAAc,GAAGH,GAAG,CAAC,CAAD,CAAH,KAAW,GAAX,IAAkBA,GAAG,CAACC,GAAD,CAAH,KAAa,GAAtD,CANuB,CAQvB;ADIN,ADJY,AkBFJ0H,AdYI,AYLZ,AHAA,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIPQA,IAAI,ClBEO3M,AIUAgH,CcZL,EAL6B,MdiBf,CAAC9F,MJVM,AIUhB,CJViBR,GIUG,CJVpB,AIUP,CJV6B,CIUC,GJVvB,EAA4BD,GAA5B,EAAiC,CAAjC,CAAP;ACKZ,ADJS,AkBFDmM,ADKA,AbOQ,AYLhB,AdLM,AWKN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,KdRQ,CAGE,EkBFFA,CDKK,CfHHzH,EEUUwB,CJVJrG,AiBGCoJ,AbOI,CJVX,AiBGQ,EjBHA,AIUM1C,CaPH,CAAb,CCLW,CDKK0C,CCLH,ADKI,GAAGrC,AfHJ,CEUS,CclBU,AdkBTL,EFVN9B,OeGW,AbOI,CaPHhE,AbOIA,MaPpC,AbO0B,AFV5B,EeG0CwI,AfHJ,CeGK,AbOI,CAApB,CaPzB,AbOQ,EaPqC;AhBErD,ADJY,AkBFJmD,ADKI,AbOI,AYLhB,AdLQ7H,AWKR,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIPQ6H,AhBEA7H,EeGQ,CfHL,CeGOpD,AbOEgF,CaPD,AbOE,CFVP5B,EEUUgC,CFVP,CeGO0C,AfHNtE,CeGF,CCLI,ADKR,ECLU,ADKM,GbOK,CAAC4B,CcnBS,AhBS7B,CAAc,CAAd,EAAiB/B,GAAjB,CEU6B,AFVnC,CEUoC/D,AFXA,CAGpC,KEQ0B,GAAmB,CAApB,CAAjB;AHLhB,ADJY,AkBFJ4L,ADKQ,AbOA,AYLhB,AHAA,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIPQA,IDKYnD,AbOA,CJVD3J,AIUE2G,CAAC,CAACE,CAAF,GcZF,AdYQD,CaPC,AbOA,CcZP,AdYQC,CAAT,CaPWiB,GCbY,CdoBRpB,CAAC,CJVD,AIUEI,CJVDpG,AiBGE,AbOH,CaPI6G,CAAC,CAAC3F,AbOAgF,CJVtB,AiBGqB,AbOE,CJVD,AiBGF,AbOIE,CaPC8C,AbOxB,GJVD,EAA4BnJ,AIUE,CAACkG,CAAC,CJVhC,AiBGmB,AbOcG,CAAF,CJVE,AiBGES,CjBHnC,AiBGoC,CjBH3C,AiBG4CmC,AbOA9C,CaPD,AbOE,CaPH,AbOIE,CaPC8C,AbOV,KAAelD,CAAC,CAACG,CaP5B,AbO0B,CaPhD,EbOsDD,CAAC,CAACC,CAAvB,CAAjC,EACIG,SAAS,CAACD,GAAV,GADJ,KAGI;AHRpB,ADJS,AkBFDgG,AdeK,AYRb,AdJQ,AWIR,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIPQA,IhBGI7H,cAAJ,EAAoB,EgBHE,EAAE,IATW;AjBgB3C,ADJK,AkBFG8H,ADIQ,ADGhB,AdJUhI,AWIV,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIPQgI,EhBGEhI,EeCU2E,CfDP,GAAG3E,CgBHC,EAAE,AhBGA,CeCS,AfDRK,IeCYmE,GfDhB,CAAYxF,WeCZ,AfDA,EeCiC,AfDRF,OAAzB,CAAN;ADIV,ADFC,AkBf0C,ADevB,AbURkD,AYPZ,AdJS,AWIT,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,MVOYA,CczBA,CAAN,CAHkB,CAgBlB,IDEkB6C,CbUH,CAAChI,IAAV,CAAe6E,CAAf,KaVyB,GAAGuC,cAAc,CAAC1B,CAAC,CAACmC,CAAD,CAAF,EAAOP,gBAAP,CAAlC;AhBGpB,AGQS,AYPT,AdJO,AWIP,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,OZXM,MAOO;ADIb,ADHA,AkBFM8D,ADEc,ADIpB,AdJQ,AWIR,APAA,AMAA,ADAA,AHAA,AMAA,MINMA,GlBEGtM,KiBAekJ,UjBAxB,AkBFwB,ClBECjJ,AkBFAsK,EDEY,GAAG,CjBAxC,AiBAoB,EjBAa,AiBAU,CCFnB,CAAlB,CAjBkB,CAmBlB;AjBIN,ADHI,AiBAoB/B,AbUhBnC,AYNR,AdJQhC,AWIR,APAA,AMAA,ADAA,AHAA,AMAA,IVMQgC,EJVA/G,EEAA+E,GAAG,CeAamE,CbUP,CAACpC,AFVJ/B,GEUN,AFVS,CAACM,IAAJ,EFAY,AEAlB,IeAgC,CjBAT/E,AiBAUkJ,YjBArC,CiBAoC,CjBAK,AiBArB,CAAgC5H,IAAhC,CAAqC0F,CAAC,CAACmC,CAAD,CAAtC;AhBIxB,ADHQ,AkBDF,ADCe,AbWb,AYPR,AdJO,AWIP,APAA,AMAA,ADAA,AHAA,AMAA,QVOYjD,EcZFyG,CDDU,MAEO,AbWN,CAAChM,GaXS2I,ECDR,CdYX,IAAoB,CAApB,IAAyB7C,CaXO,KAAKyC,GbWH,CAACvI,EcZjBgK,IdYO,GaXV,CbW8B,CcZlC,ADCyC,AbWpD,CcZN,GdYwDzE,SAAS,CAAC,CAAD,CAAT,CAAaI,CAAb,IAAkBG,SAAS,CAAC,CAAD,CAAT,CAAaH,CAAjF,IAAsFJ,SAAS,CAAC,CAAD,CAAT,CAAaK,CAAb,IAAkBE,SAAS,CAAC,CAAD,CAAT,CAAaF,CAAzH,EACI,OAAOL,SAAP,CADJ,KAGI,OAAOA,SAAS,CAACtF,MAAV,CAAiB6F,SAAjB,CAAP;AHVZ,ADHQ,AiBAgB,AbcnB,AYVL,AHAA,APAA,AMAA,ADAA,AHAA,AMAA,GVhCI,QJ4BWzG,KiBAauJ,MAAM,CjBAP,CAAClJ,CiBASuI,KjBAV,CAAnB,UiBA6C,CAACM,aAAD,CAAhB,CAAgCtI,MAAhC,CAAuCgI,gBAAgB,CAACU,aAAD,CAAvD,CAAb;AhBIxB,ADHK,AkBFC,ADEkBV,ADIxB,AdJM5E,AWIN,APAA,AMAA,ADAA,AHAA,AMAA,GdRiC,CAK7B,EEDEA,GAAG,CgBFC4I,AhBEApI,EeAcoE,CfAf,CAAH,GAAWnE,GAAX,MgBFoB,EDEc,CCFXoI,ADEYrD,MAAjB,CAAwBN,aAAxB,EAAuC,CAAvC,GCF+B,CAACyD,aAAD,CAAjD;AjBMN,AiBLMG,ADEkBlE,AbepB,AYXJ,AdJK,AWIL,APAA,AMAA,ADAA,AHAA,AMAA,KZ1BI,CgBoBEkE,CdiBG9G,IFfE,CeAa4C,GfAT9E,KAAJ,EAAW,CEelB,CcjBoB,CAAC8I,CdiBG,EafY,CAACpD,MAAjB,CAAwBF,AbeV5C,CAAV,EAAaC,CAAb,CcjBJ,CAAlB,AdiBsC,CcvCpB,CAwBlB,KDAkB,EAAuC,CAAvC;AhBIxB,AgBHwBiC,AbehB,AYXR,AdJMxF,AWIN,APAA,AMAA,ADAA,AHAA,AMAA,MZJMA,EEeMsD,CAAC,AFfJ,CEeKJ,CAAF,CafYsC,EbeNjC,CAAC,CAACL,CAAZ,EACI,OAAO,CAAC,CahBoB,AbgB5B,CahB6BhF,AbejC,IafgB,CAAsBiI,AbiBjC,IAAI7C,CAAC,CajBM,AbiBLJ,CAAF,GAAMK,CAAC,CAACL,CAAZ,EACD,OAAO,CAAC,CAAR,CADC,KAEA,EFnB8CjC,EEmB1CqC,CAAC,AFnB4C,CEmB3CH,CAAF,CFnBgD,CAAxD,CEmBcI,CAAC,CAACJ,CAAZ,EACD,OAAO,CAAC,CAAR,AFpB2DnC,CEmB1D,GFnBJ,EEqBI,AFrBP,IEqBWsC,CAAC,CAACH,CAAF,GAAMI,CAAC,CAACJ,CAAZ,EACD,OAAO,CAAC,CAAR,CADC,KAGD,OAAO,CAAP;AHpBZ,ADJI,AkBAEwG,ADCkB7D,AbwBnB,AYpBL,AdJK,AWIL,APAA,AMAA,ADAA,AHAA,AMAA,GVSI,GJdI,AkBAF6D,ClBAGrN,KiBCewJ,YCDA,ClBAG,AkBAFkC,ADCY,GAAGxC,EjBDR/I,ciBCwB,CAACc,GCDT,ClBAvC,AkBAwCqM,EDCT,EjBDe,CAACtN,AiBCU,CAA1C,SCDwC,CAACiL,OlBAzD,EkBAwD,CAAhB,CAAxB,ClBAuD3K,AkBAzE,YlBAF,EAAyF;ACK7F,ADJQN,AkBAFuN,ADCkB3D,AbyBvB,AYrBD,AdJG,AWIH,APAA,AMAA,ADAA,AHAA,AMAA,CVlDiB,EAAjB,AFiBE,CF4BM5J,EkBAFuN,MDCkB3D,UjBDE,GAAGtJ,AiBCQ,GAAGkJ,KCDP,IlBAzB,IiBCgB;AhBIxB,ADJQ,AkBAH,ADCgB,AbyBrB3J,AYrBA,AdHE,AWGF,APAA,AMAA,ADAA,AHAA,AMAA,KInCI,CdwDE,CAACC,EFxBEwE,EFFMhE,CEEb,EEwBF,GAAiB0F,MJ1BU,CAACrF,GI0B5B,GJ1B2B,CAAnB;ACKR,ADJK,AkBAF,ADCc,ADIjB,AdHC,AWGD,APAA,AMAA,ADAA,AHAA,AMAA,EZDA,CgBtCE;AjBuCF,AiBJC,ADCY,ADIb,AHAA,APAA,AMAA,ADAA,AHAA,AMAA,CIzCA;AjByCA,ADLI,AiBEK,ADIT,AHAA,APAA,AMAA,ADAA,AHAA,AMAA,MdNQ;ACMR,ADLQ,AkBER,ADAK,ADIL,AdHA,AWGA,APAA,AMAA,ADAA,AHAA,AMAA,IIJM2M,KhBCGhI,MAAT,CAAiBnB,GgBDI,GAAG,SAAlBmJ,eAAkB,CAACE,cAAD,EAAoB;AjBI5C,ADLQ,AkBEN,AFIF,AdJyB,AWIzB,APAA,AMAA,ADAA,AHAA,AMAA,MIJMC,IAAI,ClBFKzN,EkBEF2K,IAAI,CAAC1G,KAAL,CAAW0G,IAAI,ClBFK,AkBEJC,ClBFKjK,MAAD,CAAzB,CkBEgB,CAAe6M,cAAf,CAAX,CAAX;AjBIF,ADLK,AkBGHC,ADFE,ADKJ,AdLA,AIKA,AMAA,ADAA,AHAA,AMAA,EIHEA,ClBNE,CAGE,EkBGA,CAACpH,EDFI6C,EjBDE7I,AkBGX,ClBHI,AkBGM,ElBHG,QkBGO2G,CAAV,EAAaC,ADFrB,CCEQ,EAAgB;AjBG5B,ADLQ,AkBGJ,ADFH,ADKD,AdNsD,AIMtD,AMAA,ADAA,AHAA,AMAA,QdNY,GkBGDD,CAAC,CAACS,SAAF,GAAcR,CAAC,CAACQ,SAAvB;AjBGJ,ADLY,AkBGT,AFGH,AdPgF,AIOhF,AMAA,ADAA,AHAA,AMAA,GILE;AjBKF,ADLY,AiBCZ,ADKA,AdPE,AIOF,AMAA,ADAA,AHAA,AMAA,MZPMlC,GeEGwE,IjBDU/J,GEDH,GAAGyD,IAAI,CAAC+B,GeExB,CAA4B4B,GjBDS,AEDlB,CFCmB3G,AEDNb,IFCb,CAAwB,EiBC3C,AfFuC,CAACuD,CFCrB,AiBCsB,EjBDQxC,AEDjB,EAAb,EAA4B,EFC5B,CAAP,GEDO,CAAjB;ADOF,ADLS,AkBGP,ADFE,ADKJ,AdPE,AIOF,AMAA,ADAA,AHAA,AMAA,KdTQ,CAGE,AkBGJ8M,ADFEzD,AfFFvE,IgBII,CAACxE,ElBHMZ,CAAP,EAAS,CkBGb,EDFe,CCED,CAAlB,CDFsB,CCED,CDFnB;AhBKJ,ADLY,AkBGR,ADFA+G,ADKJ,AdRe,AIQf,AMAA,ADAA,AHAA,AMAA,EGLIA,MCEIsG,IAAI,CDFG,CAACjJ,CCEDgJ,IAAI,CAACA,CDFhB,CAAoB,ECEA,CAACxM,MAAL,CDFIqG,CAAC,CCES,CAAf,ADFU,CCEd,CAAsBG,SAAtB,GAAkCgG,IAAI,CAAC,CAAD,CAAJ,CAAQhG,SAArD;AjBGJ,ADLY,AkBGR,ADFIuC,ADKR,AdTc,AISd,AMAA,ADAA,AHAA,AMAA,IGLQA,AfJuB,IgBMvBrI,CAAC,ChBNP,EgBMU,CAAR,IDFiB,CAACC,IAAd,CAAmB;AhBK3B,ADLY,AkBGR6L,ADFQ7G,ADKZ,AdTE,AISF,AMAA,ADAA,AHAA,AMAA,IIHI6G,EDFQ7G,AfJNxC,CeIO,CCEL,CAACK,ADFM6C,CAAC,CAACqC,AfJN,EFGQ3J,CEHL,EgBMV,CAAa,EDFF,AfJb,CeIwBiI,GADC,ICGT0F,IlBHmB,CAAClN,EkBGrB,ElBHE,AkBGW,ClBHa,IAAxB,EAA8BE,MAA9B,CAAP;ACMZ,ADLS,AkBGH,ADFMkG,ADKZ,AVAA,AMAA,ADAA,AHAA,MSLYA,CAAC,EAAES,CCELsG,ADFM,CAACjE,MCEA,EDFF,CCEM,ADFKxB,CCEJwF,OAAO,CAAClG,SAAR,GAAoBgG,IAAI,CAAC,CAAD,CAAJ,CAAQhG,SAA7B,IAA0CiG,IAA3C,GAAmD,GAAjE;AjBGN,ADLK,AkBGCC,ADLqB,ADQ3B,AdTE,AISF,AMAA,ADAA,AHAA,KSRQ,CCKFA,AhBNAxJ,OgBMO,AhBNX,CgBMY8H,ChBNC,KgBMT,GAAiB4B,UAAU,CAACD,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAD,CAAV,GAAiC,CAAlD;AjBGN,ADFC,AkBAI,ADFA,ADKL,AdTI,AISJ,AMAA,ADAA,AHAA,GSVI,ECIA,GhBHI3J,OAAO,CAACV,IAAR,IAAgB,IAApB,EAA0B;ADS9B,AiBFG,ADFC,ADKJ,AdTM8B,AISN,AMAA,ADAA,AHAA,MNTMA,GeIKyE,OfJK,GAAG7F,GeIf,IfJsB,CAACV,IAArB;ADSN,ADHA,AiBDC,ADKD,AdTK,AISL,AMAA,ADAA,AHAA,IRJI7C,KAAK,GAAG,EAAZ;ACIA,ADHA,AkBCE,AFGF,AVAA,AMAA,ADAA,AHAA,IRJIC,KkBCK4M,GlBDG,CkBCV,ElBDa,KAAf;ACIA,ADHA,AkBCC,ADFD,ADKA,AdVI,AIUJ,AMAA,ADAA,AHAA,CUpBA,GlBgBI3M,IENIqD,CeKC8F,MfLM,CFMf,AENgBxE,QAAR,IAAoB,IAAxB,CeKJ,CAAkC2B,AfLA,WeKlC,EAA+C;AhBK/C,ADHA,AkBGA,ADJI,ADKJ,AdVM3B,AIUN,AMAA,ADAA,AHAA,IRJI1E,EiBDImJ,AfLFzE,QFMQ,AENA,GFMG,AENAtB,CFMC,CAAlB,IiBDyB,CfLD,CAACsB,CeKG,EAAxB,KfLE;ADUN,AgBJI2B,ADKJ,AdVK,AIUL,AMAA,ADAA,AHAA,ESLIA,WAAW,CAAC3C,OAAZ,CAAoB,UAAA6C,CAAC,EAAI;AhBK7B,ADHA,AiBDQ4C,ADKR,AVAA,AMAA,ADAA,AHAA,ISLQA,KjBCClJ,YiBDgB,CAACY,EjBC1B,EiBDQ,CjBCmB,AiBDI;AhBK/B,ADHI,AiBDQqG,ADKZ,AdXI,AIWJ,AMAA,ADAA,AHAA,MRJQ,AiBDIA,CjBCHpH,CEPDsD,CeMO,EAAEmD,CAAC,CAACV,CADY,CjBEvB,AEPO,CAACxC,GFOK,CAACtD,CEPd,IAAiB,IAArB,EAA2B,CFO3B,EAAgC;ACIpC,ADHQ,AiBDIqH,ADKZ,AdXM/D,AIWN,AMAA,ADAA,AHAA,MSLY+D,AfNN/D,GeMS,EAAEkD,AfNN,CeMO,CAACT,CfNL,IAAR;ADWN,ADHK,AkBEL,ADN+B,ADQ/B,AdXK,AIWL,AMAA,ADAA,AHAA,IUFMkH,CDNE,WCMU,GAAG,SAAfA,YAAe,CAAC3G,WAAD,EAAc4G,MAAd,EAAsBC,QAAtB,EAAgChC,MAAhC,EAAwCiC,MAAxC,EAAgDC,QAAhD,EAA6D;AjBElF,AiBAE,ADJG,ADKL,AdXG,AIWH,AMAA,ADAA,AHAA,GSVI,GCSEC,YAAY,GAAG,IAAItC,MAAM,CAACC,IAAP,CAAYsC,OAAhB,CAAwB;AjBC7C,ADJIxN,AkBIAyN,ADJA,ADKJ,AVAA,AMAA,ADAA,AHAA,ERLIzN,EkBIAyN,KAAK,ADJEpE,CjBAC,CkBID9C,ElBJI,KAAX,IkBGyC,IDHzC;AhBKJ,AiBAImH,ADJH,ADKD,AdXE,AIWF,AMAA,ADAA,AHAA,IUDIA,EhBVE,SgBUS,EAAEP,MAF4B;AjBG7C,ADLI,AkBKAQ,AFCJ,AdXI,AIWJ,AMAA,ADAA,AHAA,IUDIA,ElBLI1N,WkBKS,ClBLG,CAACG,AkBKFgN,MlBLf,EAAyB,AkBEgB;AjBI7C,ADLQrN,AkBKJ6N,ADJJ,ADKA,AdXI,AIWJ,AMAA,ADAA,AHAA,IRNQ7N,AkBKJ6N,IhBVM/I,CFKG,AiBCJyE,GjBDOrJ,EELA,EgBUA,ChBVGmD,CgBUDgI,IhBVM,CAAC1I,CFKG,AkBCiB,ClBDhBrC,AiBC7B,AfN2B,CeMDkG,AfNEzB,KFKZ,CAAoB/E,KAApB,AiBChB,CjBDQ,AELiB,CeMc,AfNE2E,UAAhB,EAA4B;ADWrD,ADLK,AkBKDmJ,ADJA,ADKJ,AdZuDjJ,AIYvD,AMAA,ADAA,AHAA,GRRI,CkBOAiJ,EDJI1E,AfP+CvE,GFM5C,IkBKE,ChBXkD,CgBWhDyI,ChBXwCzI,GeOlC,ECDwB,CDCrBsE,kBAAkB,CAAC3C,WAAD,CAAtC,CADmC,CAEnC;AhBIJ,ADLQrG,AkBKJ4N,AFCJ,AdbqD,AIarD,AMAA,ADAA,AHAA,IRNQ5N,AkBKJ4N,ChBZqB,CAAD,EAA4C,MFOlD,CkBKH,ElBLM,AkBKJR,ClBLK,CAAd,MkBDqC;AjBO7C,ADLK,AkBKDS,ADJA,ADKJ,AddsExK,AIctE,AMAA,ADAA,AHAA,IUDIwK,EDJIxE,AfT8DhG,KAAK,EgBa9D,AhBbyDA,EgBavD,ADJE,GAAG8C,UAAU,CAAC8C,aAAD,CAA1B;AhBKJ,AiBR6C,ADIzC,ADKJ,AdfoE,AIepE,AMAA,ADAA,AHAA,GUTqB,CAAnB,ChBNsB,CeUhBK,AfVJ,aeUiB,GAAGJ,wBAAwB,CAACG,SAAD,CAA5C;AhBKJ,ADNI,AkBOF,ADLE,ADKJ,AddIxE,AIcJ,AMAA,ADAA,AHAA,INdIA,EFOIhF,GkBOCwN,ADLE/D,CfTD,CFOG,AEPFxE,CFOG5E,GEPV,CAAYyE,EFOZ,EAAkB,CkBOpB,CDLE,AfTA,EAAoBjB,OAApB,CAA4B,UAAUK,GAAV,EAAe;ADc/C,ADNQ3D,AkBOP,ADLA,ADKD,AddM,AIcN,AMAA,ADAA,AHAA,CUbA,GlBMQA,MEPE,CAACyE,GFOO,GEPD,CAAC7D,SAAP,CAAiB+D,cAAjB,CAAgCrF,IAAhC,CAAqCb,OAAO,CAACsC,GAA7C,EAAkD4C,GAAlD,CAAL,EAA6D;ADcnE,ADNK,AkBQL,AFDA,AddQlF,AIcR,AMAA,ADAA,AHAA,QNdQA,OAAO,CAACsC,GAAR,CAAY4C,GAAZ,IAAmBY,MAAM,CAACZ,GAAD,CAAzB;ADcR,ADNC,AiBED,ADKA,AddO,AIcP,AMAA,ADAA,AHAA,ONhBM,EeWGwF,IfTI,IAAIlG,KAAJ,EAAW,sBeSxB,CAA+C8E,gBAA/C,EAAiE;AhBKjE,AgBJI,ADKJ,AddQxF,AIcR,AMAA,ADAA,AHAA,MSLQ6G,EfTA7G,GAAG,GeSK,GAAG,EAAf,KfTYoB,GAAL,wEAAH;ADcR,ADNA,AiBEIoE,ADKJ,AddO,AIcP,AMAA,ADAA,AHAA,ESLIA,OjBFK/H,SiBEW,CjBFpB,AiBEqBsD,GjBFC,IiBElB,CAAyB,UAAA+F,KAAK,EAAI;AhBKtC,ADNI,AiBEID,ADKR,AddK,AIcL,AMAA,ADAA,AHAA,ISLQA,CffJ,CFaI1J,MiBEQ,CAACe,CjBFb,EAAc,CiBEV,CAAcuI,gBAAgB,CAACK,KAAD,CAA9B;AhBKR,ADNQ,AkBOR,ADLK,ADKL,AdbI,AIaJ,AMAA,ADAA,AHAA,GSPI,CCOEwC,OhBbK,WgBaa,GAAG,SAArBA,kBAAqB,CAAC5F,WAAD,EAAiB;AjBA5C,ADNK,AkBOH,ADLE,ADKJ,Adda1B,AIcb,AMAA,ADAA,AHAA,MUAMmJ,AhBdOnJ,GeSF6E,GfTQ,EgBcL,AhBdD7E,GgBcI6E,ADLb,QCKqB,CAACnD,WAAD,EAAc,CAAd,CAAR,CAAyB,aAAzB,CAAf;AjBAF,AiBCEyH,ADLD,ADKD,AdfW,AIeX,AMAA,ADAA,AHAA,EUAEA,GhBfE,KgBeM,CAACpK,OAAT,CAAiB,UAAAqK,UAAU,EAAI;AjBAjC,ADPI,AkBQA,AFAJ,AdfG,AIeH,AMAA,ADAA,AHAA,GN5BE,CAaE,EFOI1N,EkBQAgI,GhBfG/I,CAAP,CFOW,CEPD,CgBeC,ClBRGE,EkBQAwN,QlBRU,CAAC/M,GkBQC,CAAC8N,UAAD,ClBRF,CAAxB,AkBQuC,oBAAb,EAAmC,GAAnC,EAAwC,CAAxC,EAA2C,oBAA3C,EAAiE,GAAjE,CAA1B;AjBAJ,ADPIjO,AkBQAuI,ADLJ,ADKA,AdfI,AIeJ,AMAA,ADAA,AHAA,ERRIvI,EkBQAuI,KDLKqB,CjBHG,CkBQD,AhBfA,CgBeCsE,ClBRG,IAAX,CkBQA,CAAezD,ADLnB,CAAoBlE,ECKhB,SDLJ,EAAiCmC,eAAjC,EAAkD;AhBKlD,ADNI,AkBOD,ADLC,ADKJ,AdhBaxD,AIgBb,AMAA,ADAA,AHAA,GUHE,GlBJM1E,AiBEAqJ,AfXK3E,GFSF,EETO,CFSJnF,CETMP,IFSD,CAACY,EiBEE,GAAG0J,CjBFrB,GiBEyB,CAAC1G,KAAL,CAAW0G,IAAI,CAACC,SAAL,CAAexD,WAAf,CAAX,CAArB;AhBKJ,AiBCC,ADLG,ADKJ,AdjBW,AIiBX,AMAA,ADAA,AHAA,CUNA,IhBXI,CeYIyD,MAAM,GAAGvB,0BAA0B,CAACoB,cAAD,EAAiBnB,eAAjB,CAAvC;AhBKJ,ADPI,AkBUJ,ADPI,ADKJ,AdjBG,AIiBH,AMAA,ADAA,AHAA,MSLQgB,GjBHElJ,GAAN,EAAW,AiBGC,GAAGiJ,qCAAqC,CAACO,MAAD,CAApD;AhBKJ,ADPQ/J,AiBGJ,ADKJ,AdjBC,AIiBD,AMAA,ADAA,AHAA,IRRQA,KiBGGyJ,OjBHS,CiBGhB,EjBHmB3J,KAAf;ACQR,ADPQA,AiBGP,ADKD,AVAA,AMAA,ADAA,AHAA,IRRQA,KAAK,GAAG,EAAR;ACQR,AeCA,AdjBAf,AIiBA,AMAA,ADAA,AHAA,MNjBM,CAACC,OAAP,CAAewF,MAAf,GAAwBA,MAAxB;ADiBA,ADRQ,AiBMR,ADGA,AdjBAzF,AIiBA,AMAA,ADAA,AHAA,MNjBM,CAACC,EecEwB,EjBNM,CiBMf,CjBNiBP,AiBMJqG,Cfdb,CAAenD,KAAf,GFQe,AERQA,CecvB,EjBN8B5C,AiBMJkI,Efd1B,CFQQ,EAA2B,UiBMnC,EAA2C;AhBG3C,ADRY,AkBUZ,ADJI,ADGJ,AVAA,AMAA,ADAA,AHAA,IUCM8D,EDJEhG,IjBNQvG,YAAJ,AkBUY,CDJC,CjBNK,CkBUH,CDJCqG,QCItBkG,QDJsC,CAACjG,SCIlB,CAACA,CDJgB,CAAxC,SCIuB,EAAiB;AjBD5C,ADRgBtG,AkBWd0K,ADLE,ADGJ,AVAA,AMAA,ADAA,AHAA,EUEEA,IDLMjB,EjBNQzJ,CkBWP,GAAG,EDLI,ECKAyK,CDLG,EAAf,CjBNwB,CAACxK,KkBWH,CAACiO,IlBXC,CAAZ,CAAyB1N,GAAzB,IkBWA,CAAyB2N,YAA7B,CAA0C;AjBFtD,ADRa,AkBWTtD,AFFJ,AVAA,AMAA,ADAA,AHAA,IUEIA,IAAI,EAAEvE;AjBFV,ADRS,AkBS6C,ADJlD,ADIJ,AVAA,AMAA,ADAA,AHAA,GUAY,CAAV,GDJO,IAAItC,GAAT,IAAgBuC,iBAAhB,EAAmC;AhBIvC,AiBIEmE,ADPMjB,ADIR,AVAA,AMAA,ADAA,AHAA,EUGEiB,EDPMjB,KCOC,CAACwE,EDPM,CAACjK,GCOf,ADPc,CCOCwG,ADPT,GCON,ADPsBb,UAAU,CAACpD,iBAAiB,CAACvC,GAAD,CAAlB,EAAyByE,eAAzB,CAA1B;AhBIR,ADTQxI,AkBcNyK,ADRG,ADIL,AVAA,AMAA,ADAA,AHAA,EUIEA,ElBdMzK,KkBcC,CAACmO,GAAR,ClBdgB,AkBcJ,GlBdO,CAAC,CAAd,GkBcN,EAAsB1D,OAAO,CAAC2D,GAAR,CAAY,QAAZ,IAAwB1D,MAAxB,GAAiCA,MAAvD;AjBJF,ADTQpK,AkBeN,AFLF,AVAA,AMAA,ADAA,AHAA,IRVQA,EkBeF+N,ClBfK,GAAGxO,IkBeA,ClBfK,CAACK,CkBeH,CACb,IlBhBI,gBkBeS,EAEb,oBAFa,EAGb,qBAHa,EAIb,sBAJa,EAKb,qBALa,EAMb,oBANa,CAAf;AjBLF,ADTK,AkBuBHuK,ADlBE,ADKJ,AVAA,AMAA,ADAA,AHAA,EUaEA,OAAO,ADlBEjB,CCkBD2E,GAAR,CAAY,GDlBV,OCkBF,EAAwB1D,OAAO,CAAC2D,GAAR,CAAY,UAAZ,IAA0B,IAA1B,GAAiCC,QAAzD;AjBbF,AiBeC,ADnBA,ADKD,AVAA,AMAA,ADAA,AHAA,CUPA;AjBOA,ADVItO,AgBWJ,AVAA,AMAA,ADAA,AHAA,ERXIA,YAAY,GAAG,IAAf;ACWJ,ADVID,AkB0BJ,ADpBAhB,ADKA,AVAA,AMAA,ADAA,AHAA,ERXIgB,EkB0BEsM,EDpBA,CAACrN,GjBNK,GAAG,CiBMf,GAAiBwB,CjBNb,EiBMJ,UCoBgC,GAAG,SAA7B6L,0BAA6B,CAAC/F,WAAD,EAAiB;AjBfpD,ADVI1G,AkB2BF0G,AFhBF,AVAA,AMAA,ADAA,AHAA,ERXI1G,AkB2BF0G,WAAW,CAACf,GlB3BK,CAACjF,AkB2BlB,CAAiB,MlB3BA,CAAf,GkB2ByB4F,CAAV,EAAaC,CAAb,EAAgB;AjBhBnC,ADVC,AkB2BG,AFhBJ,AVAA,AMAA,ADAA,AHAA,WUgBWD,CAAC,CAACS,SAAF,GAAcR,CAAC,CAACQ,SAAvB;AjBhBJ,AiBiBG,AFhBH,AVAA,AMAA,ADAA,AHAA,GUcE;AjBdF,ADVA7H,AkB6BE,AFlBF,AVAA,AMAA,ADAA,AHAA,MUkBMyP,ClB7BC,CAAC9N,QAAR,EkB6BkB,ClB7BC,EkB6BE+N,QlB7BQ9O,GAAV,EAAe,AkB6BA,CAAC4G,WAAD,EAAc,CAAd,CAAhC,CAPkD,CASlD;AjBpBF,ADVI,AgBWJ,AVAA,AMAA,ADAA,AHAA,MRXQ5F,IAAI,GAAG,IAAIC,KAAJ,CAAUC,SAAS,CAACT,MAAV,GAAmB,CAA7B,CAAX;ACWJ,AiBoBEoO,AFnBF,AVAA,AMAA,ADAA,AHAA,EUmBEA,YAAY,CAAC,CAAD,CAAZ,CAAgB5K,OAAhB,CAAwB,UAAAkJ,OAAO,EAAI;AjBnBrC,ADXI,AkB+BAA,AFnBJ,AVAA,AMAA,ADAA,AHAA,IUmBIA,ElB/BIjM,KkB+BG,CAAC6N,GlB/BK,CAACtO,CkB+Bd,GAAgB,ElB/BZ,GAAmB,CAAvB,EAA0B,ckB+B1B;AjBnBJ,ADXQ,AkB+BL,AFnBH,AVAA,AMAA,ADAA,AHAA,GUiBE,MlB7BW,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,SAAS,CAACT,MAA9B,EAAsCU,CAAC,EAAvC,EAA2C;ACYnD,ADXYH,AkBgCV6N,AFpBF,AVAA,AMAA,ADAA,AHAA,EUoBEA,IlBhCU7N,IAAI,CAACG,CAAC,EkBgCJ,ClBhCO,AkBgCN,ClBhCC,AkBgCF,ClBhCF,AkBgCV,CAAgB8C,ElBhCQ/C,KkBgCxB,CAAwB,GlBhCS,CAACC,CAAD,CAAvB,IkBgCcgM,OAAO,EAAI;AjBpBrC,ADXS,AkBgCLA,AFpBJ,AVAA,AMAA,ADAA,AHAA,IUoBIA,OAAO,CAAC4B,KAAR,GAAgB,oBAAhB;AjBpBJ,ADXK,AkBgCF,AFpBH,AVAA,AMAA,ADAA,AHAA,GUkBE;AjBlBF,AiBsBEF,AFrBF,AVAA,AMAA,ADAA,AHAA,EUqBEA,YAAY,CAAC,CAAD,CAAZ,CAAgB5K,OAAhB,CAAwB,UAAAkJ,OAAO,EAAI;AjBrBrC,ADZI/M,AkBkCA+M,AFrBJ,AVAA,AMAA,ADAA,AHAA,ERbI/M,EkBkCA+M,GlBlCK,CAAC/L,GkBkCC,ClBlCP,AkBkCQ2N,ClBlCG,IAAI1N,AkBkCf,GAAgB,ClBlCL,CAASrB,GAAT,EAAcgB,IAAd,CAAX,SkBkCA;AjBrBJ,AiBsBG,AFrBH,AVAA,AMAA,ADAA,AHAA,GUmBE;AjBnBF,ADbI,AkBoCF6N,AFtBF,AVAA,AMAA,ADAA,AHAA,EUsBEA,IlBpCMzO,KAAK,CAACK,EkBoCA,CAAC,CAAD,CAAZ,ClBpCM,AkBoCUwD,KlBpCO,CAAjB,CkBoCN,CAAwB,ElBpCI,CAAC5D,OkBoCL8M,ClBpCtB,EAAqC,IkBoCR,EAAI;AjBtBrC,ADbQpN,AkBoCJoN,AFtBJ,AVAA,AMAA,IZdQpN,AkBoCJoN,OAAO,CAAC4B,ElBpCM,CAACpO,EkBoCf,GAAgB,KlBpCF,CAAV,gBkBoCJ;AjBtBJ,ADbK,AkBoCF,AFtBH,AVAA,AMAA,GMoBE;AjBpBF,ADbC,AkBqCCkO,AFvBF,AVAA,AMAA,CZzBA,CkBgDEA,ClBnCF,WkBmCc,CAAC,CAAD,CAAZ,CAAgB5K,OAAhB,CAAwB,UAAAkJ,OAAO,EAAI;AjBvBrC,AiBwBIA,AFvBJ,AVAA,AMAA,IMuBIA,OAAO,CAAC4B,KAAR,GAAgB,qBAAhB;AjBvBJ,AiBwBG,AFvBH,AVAA,AMAA,GMqBE;AjBrBF,ADbA,AkBsCEF,AFxBF,AVAA,AMAA,EMwBEA,OlBtCOxN,IAAT,CAAcrB,AkBsCA,CAAC,CAAD,ClBtCd,AkBsCE,CAAgBiE,ClBtCC3C,KAAnB,CkBsCE,ClBtCwB,AkBsCA,UAAA6L,OAAO,EAAI;AjBxBrC,ADbI,AkBsCAA,AFxBJ,AVAA,AMAA,IMwBIA,GlBtCKnN,GAAL,CkBsCO,CAAC+O,ClBtCG/O,GAAX,CkBsCA,GAAgB,oBAAhB;AjBxBJ,ADbI,AkBsCD,AFxBH,AVAA,AMAA,GMsBE,IlBpCOsB,KAAL,GAAaA,KAAb;ACcJ,ADbC,AkBuCC,AFzBF,AVAA,AMAA,SMyBSuN,YAAP;AjBzBF,AiB2BC,AF1BD,AVAA,AMAA,CMVA;AjBUA,ADdAxN,AgBeA,AVAA,AMAA,IZfI,CAACE,SAAL,CAAeT,GAAf,GAAqB,YAAY;ACejC,ADdI,AkB2CJ,AF5BA,AVAA,AMAA,IM4BMgO,GlB3CG9O,GAAL,CAASwB,KAAT,CAAe,AkB2CA,GAAG,ClB3ClB,EAAqB,KAAKF,CkB2CxBwN,IlB3CF,SkB2CkB,CAACxN,KAAD,EAAQ0N,KAAR,EAAkB;AjB5BxC,ADdC,AkB2CC,AF5BF,AVAA,AMAA,CZjBA,KkB6CMC,MAAM,GAAG,EAAb;AjB5BF,AeCA,AVAA,AMAA;AXAA,ADfA7P,AkB2CE,AF3BF,AVAA,AMAA,OZhBO,AkB2CA,ClB3CCqC,GkB2CGN,CAAC,ClB3CZ,EkB2Ce6N,ClB3CC,IkB2Cd,EAAoB7N,CAAC,ElB3CvB,CkB2C0B,CAAxB,EAA2BA,CAAC,EAA5B,EAAgC;AjB3BlC,ADdA/B,AkB0CI6P,AF3BJ,AVAA,AMAA,IM2BIA,GlB1CG,CAACvN,EkB0CE,ClB1CV,AkB0CWN,GlB1CG,CkB0CV,ClB1CJ,AkB0CgBE,KAAK,CAACgI,MAAN,CAAa,CAAb,EAAgBtB,IAAI,CAACkH,IAAL,CAAU5N,KAAK,CAACb,MAAN,GAAeU,CAAzB,CAAhB,CAAZ;AjB3BJ,ADdA/B,AkB0CG,AF3BH,AVAA,AMAA,OZfO,CAACuC,IAAR,GAAe,EAAf;ACeA,ADdAvC,AgBeA,AVAA,AMAA,OZfO,CAACwC,OAAR,GAAkB,EAAlB,EAAsB;ACetB,AiB2BE,AF1BF,AVAA,AMAA,SM0BSqN,MAAP;AjB1BF,ADfA7P,AkB0CC,AF1BD,AVAA,AMAA,CMoBA,MlBpCO,CAACyC,QAAR,GAAmB,EAAnB;ACgBA,AeCA,AVAA,AMAA;AXAA,ADfA,AkB2CA,AF3BA,AVAA,AMAA,IM2BM+K,KlB3CG9K,IAAT,GAAgB,CAAE,KkB2CM,GAAG,SAArB8K,kBAAqB,CAAChG,WAAD,EAAiB;AjB3B5C,AiB6BEA,AF5BF,AVAA,AMAA,EM4BEA,WAAW,CAAC3C,OAAZ,CAAoB,UAAA2C,WAAW,EAAI;AjB5BrC,ADfAxH,AkB6CI,AF7BJ,AVAA,AMAA,OZhBO,CAAC2C,CkB6CC,ClB7CT,GAAaD,AkB6CAqN,IlB7Cb,CkB6CI,IAAkBvI,WAAlB,EAA+B;AjB7BnC,ADfAxH,AkB6CM,AF7BN,AVAA,AMAA,OZhBO,CAAC4C,EkB6CEoN,SlB7CV,EkB6CqB,ClB7CCtN,EkB6CE,ElB7CxB,EkB6C4BuJ,MAAM,CAACC,MAAP,CAAcC,IAAd,CAAmB8D,MAAvB,CAA8B;AjB7BtD,ADfAjQ,AkB6CQ2O,AF7BR,AVAA,AMAA,OZhBO,CAAC9L,AkB6CA8L,IlB7CR,GAAejM,IAAf,AkB6CmB,EAAE,SADiC;AjB5BtD,ADfA1C,AkB6CQ4O,AF7BR,AVAA,AMAA,OZhBO,CAAC9L,AkB6CA8L,GlB7CR,GAAclM,IAAd,GkB6CqB,EAAE,GAF+B;AjB3BtD,ADfA1C,AkB6CQ6O,AF7BR,AVAA,AMAA,OZhBO,CAAC9L,AkB6CA8L,YAAY,ElB7CpB,AkB6CsB,CAHgC,ElB1C7BnM,IAAzB;ACgBA,ADfA1C,AkB6CQ8O,AF7BR,AVAA,AMAA,OZhBO,CAAC9L,AkB6CA8L,SAAS,EAAEtH,OlB7CnB,GAA6B9E,CkB6CC,CAACqN,ElB7C/B,GkB6C8B,CAAX,CAAmBJ,KAJgB;AjBzBtD,ADfA3P,AkB6CQ+O,AF7BR,AVAA,AMAA,OZhBO,CAAC9L,AkB6CA8L,IlB7CR,GAAerM,IAAf,AkB6CmB,EAAE,IALiC;AjBxBtD,ADfA1C,AkB6CQ0L,AF7BR,AVAA,AMAA,OZhBO,CAACxI,AkB6CAwI,GAAG,EAAEA,GANyC,OlBvCtD,GAA0BhJ,IAA1B;ACgBA,ADfA1C,AkB6CQ6M,AF7BR,AVAA,AMAA,OZhBO,CAAC1J,AkB6CA0J,MAAM,EAAErF,WlB7ChB,AkB6C2B,CAACuI,ElB7CErN,GkB6CH,ClB7C3B,AkB6CgB,CAAmBqH,QAPmB;AjBtBtD,AiB8BQ8B,AF7BR,AVAA,AMAA,QM6BQA,MAAM,EAAEjD,IAAI,CAACG,GAAL,CAASvB,WAAW,CAACuI,KAAD,CAAX,CAAmBlI,SAA5B,IAAyC,CARH,CAQK;AjB7B3D,ADfA7H,AgBgBA,AVAA,AMAA,OZhBO,CAACoD,SAAR,GAAoB,UAAUC,IAAV,EAAgB;ACgBpC,ADhBsC,AkBoCgB,AFnBtD,AVAA,OYmBwB,CAAlB,ClBpCuC,EAAP;ACiBtC,ADjBiD,AkB8C5C,AF5BL,AVAA,CNlBA;ACkBA,AiB6BG,AF5BH,AVAA,GYcE;AjBdF,ADjBArD,AkB8CC,AF5BD,AVAA,CYWA,MlB7BO,CAACsD,OAAR,GAAkB,UAAUD,IAAV,EAAgB;ACkBlC,ADjBI,AgBkBJ,AVAA,QNlBU,IAAI/C,KAAJ,CAAU,kCAAV,CAAN;ACkBJ,ADjBC,AkB8CD,AF5BA,AVAA,CNpBA,GkBgDM4P,YAAY,GAAG,SAAfA,YAAe,GAAM;AjB5B3B,AiB6BE5E,AF5BF,AVAA,EY4BEA,kBAAkB,CAACkB,gBAAnB,CAAoC,OAApC,EAA6C,YAAM;AjB5BrD,ADjBAxM,AkB8CI,AF5BJ,AVAA,ONlBO,CAACuD,AkB8CA4M,GlB9CR,GAAc,IkB8CI,GAAG5E,KlB9CK,GkB8CG,CAAC6E,aAAT,CAAuB,QAAvB,EAAiCC,KAAlD;AjB5BJ,ADlB4B,AgBmB5B,AVAA,SNnBmC,GAAP;ACmB5B,ADnBwC,AkB+CpC,AF3BJ,AVAA,CNpBA,OkB+CQF,UAAU,IAAI,GAAd,IAAqBA,UAAU,GAAG,CAAtC,EAAyC;AjB3B7C,AiB4BMtE,AF3BN,AVAA,MY2BMA,MAAM,GAAGsE,UAAT;AjB3BN,ADpBAnQ,AkBgDM4L,AF3BN,AVAA,MY2BMA,ClBhDC,CAACpI,KAAR,AkBgDa,CAAC8L,ElBhDE,CkBgDV,CAAY,QlBhDQ7L,AkBgDpB,EAAsBmI,ClBhDZ,EAAe,IkBgDI,CAAC2D,GAAR,CAAY,QAAZ,IAAwB1D,MAAxB,GAAiCA,MAAvD;AjB3BN,ADpBI,AkBgDC,AF3BL,AVAA,QNrBU,IAAIvL,KAAJ,CAAU,gCAAV,CAAN;ACqBJ,ADpBC,AkBgDE,AF3BH,AVAA,CNvBA,EkB4CE;AjBrBF,AiB4BC,AF3BD,AVAA,CYmBA;AjBnBA,ADrBAN,AkBkDA,AF5BA,AVAA,ONtBO,CAAC0D,KAAR,GAAgB,YAAW;ACsB3B,ADtB6B,AgBuB7B,AVAA,SNvBoC,CAAP;ACuB7B,ADvBwC,AgBwBxC,AVAA,CNxBA;ACwBA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AiB4BA,AF3BA,AVAA,IY2BMiK,2BAA2B,GAAG,SAA9BA,2BAA8B,GAAM;AjB3B1C,AiB4BEhC,AF3BF,AVAA,EY2BEA,UAAU,CAAC2E,KAAX,CAAiB1N,WAAjB,CAA6B8I,GAA7B,EAAkC,OAAlC,EAA2C,UAAC4E,KAAD,EAAW;AjB3BxD,AiB4BI7E,AF3BJ,AVAA,IY2BIA,GAAG,CAACzJ,IAAJ,CAAS;AjB3Bb,AiB4BM+H,AF3BN,AVAA,MY2BMA,QAAQ,EAAE,IAAIkC,MAAM,CAACC,MAAP,CAAcC,IAAd,CAAmBC,MAAvB,CAA8B;AjB3B9C,AiB4BQ/D,AF3BR,AVAA,QY2BQA,GAAG,EAAEiI,KAAK,CAACC,MAAN,CAAalI,GAAb,EADiC;AjB1B9C,AiB4BQE,AF3BR,AVAA,QY2BQA,GAAG,EAAE+H,KAAK,CAACC,MAAN,CAAahI,GAAb;AjB3Bb,AiByB8C,AFxB9C,AVAA,OYwBgB,CADH;AjBvBb,AiB4BM8D,AF3BN,AVAA,MY2BMA,MAAM,EAAE,CALD;AjBtBb,AiB4BMxE,AF3BN,AVAA,MY2BMA,SAAS,EAAED,IAAI,CAAC4I,GAAL;AjB3BjB,AiBqBa,AFpBb,AVAA,KYoBI;AjBpBJ,AiB4BI5E,AF3BJ,AVAA,IY2BIA,OAAO,CAACuD,MAAR,CAAe,IAAf;AjB3BJ,AiB4BI,AF3BJ,AVAA,QY2BQpD,IAAI,GAAG2B,eAAe,CAACjC,GAAD,CAA1B;AjB3BJ,AiB4BI,AF3BJ,AVAA,QY2BQjE,WAAW,GAAGsE,uBAAuB,CAACC,IAAD,CAAzC;AjB3BJ,AiB4BI0B,AF3BJ,AVAA,IY2BIA,kBAAkB,CAACjG,WAAD,CAAlB;AjB3BJ,AiB4BG,AF3BH,AVAA,GYcE;AjBdF,AiB4BC,AF3BD,AVAA,CYYA;AjBZA,AeCA,AVAA;ALAA,AiB4BA8E,AF3BA,AVAA,OY2BO;AjB3BP,AiB4BA4D,AF3BA,AVAA,YY2BY;AjB3BZ,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.c328ef1a.js","sourceRoot":"..","sourcesContent":["// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nconst fs = require('fs')\nconst path = require('path')\n\nfunction log (message /*: string */) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nconst NEWLINE = '\\n'\nconst RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/\nconst RE_NEWLINES = /\\\\n/g\nconst NEWLINES_MATCH = /\\n|\\r|\\r\\n/\n\n// Parses src into an Object\nfunction parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {\n  const debug = Boolean(options && options.debug)\n  const obj = {}\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(RE_INI_KEY_VAL)\n    // matched?\n    if (keyValueArr != null) {\n      const key = keyValueArr[1]\n      // default undefined or missing values to empty string\n      let val = (keyValueArr[2] || '')\n      const end = val.length - 1\n      const isDoubleQuoted = val[0] === '\"' && val[end] === '\"'\n      const isSingleQuoted = val[0] === \"'\" && val[end] === \"'\"\n\n      // if single or double quoted, remove quotes\n      if (isSingleQuoted || isDoubleQuoted) {\n        val = val.substring(1, end)\n\n        // if double quoted, expand newlines\n        if (isDoubleQuoted) {\n          val = val.replace(RE_NEWLINES, NEWLINE)\n        }\n      } else {\n        // remove surrounding whitespace\n        val = val.trim()\n      }\n\n      obj[key] = val\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)\n    }\n  })\n\n  return obj\n}\n\n// Populates process.env from .env file\nfunction config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding /*: string */ = 'utf8'\n  let debug = false\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = options.path\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n    if (options.debug != null) {\n      debug = true\n    }\n  }\n\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`)\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    return { error: e }\n  }\n}\n\nmodule.exports.config = config\nmodule.exports.parse = parse\n","const API_URL = 'https://maps.googleapis.com/maps/api/js'\nconst CALLBACK_NAME = '__googleMapsApiOnLoadCallback'\n\nconst optionsKeys = ['channel', 'client', 'key', 'language', 'region', 'v']\n\nlet promise = null\n\nmodule.exports = function (options = {}) {\n  promise =\n    promise ||\n    new Promise(function (resolve, reject) {\n      // Reject the promise after a timeout\n      const timeoutId = setTimeout(function () {\n        window[CALLBACK_NAME] = function () {} // Set the on load callback to a no-op\n        reject(new Error('Could not load the Google Maps API'))\n      }, options.timeout || 10000)\n\n      // Hook up the on load callback\n      window[CALLBACK_NAME] = function () {\n        if (timeoutId !== null) {\n          clearTimeout(timeoutId)\n        }\n        resolve(window.google.maps)\n        delete window[CALLBACK_NAME]\n      }\n\n      // Prepare the `script` tag to be inserted into the page\n      const scriptElement = document.createElement('script')\n      const params = [`callback=${CALLBACK_NAME}`]\n      optionsKeys.forEach(function (key) {\n        if (options[key]) {\n          params.push(`${key}=${options[key]}`)\n        }\n      })\n      if (options.libraries && options.libraries.length) {\n        params.push(`libraries=${options.libraries.join(',')}`)\n      }\n      scriptElement.src = `${options.apiUrl || API_URL}?${params.join('&')}`\n\n      // Insert the `script` tag\n      document.body.appendChild(scriptElement)\n    })\n  return promise\n}\n","/* \n * Convex hull algorithm - Library (JavaScript)\n * \n * Copyright (c) 2018 Project Nayuki\n * https://www.nayuki.io/page/convex-hull-algorithm\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program (see COPYING.txt and COPYING.LESSER.txt).\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\n\"use strict\";\n\n\nvar convexhull = new function () {\n\n    // Returns a new array of points representing the convex hull of\n    // the given set of points. The convex hull excludes collinear points.\n    // This algorithm runs in O(n log n) time.\n    this.makeHull = function (points) {\n        var newPoints = points.slice();\n        newPoints.sort(this.POINT_COMPARATOR);\n        return this.makeHullPresorted(newPoints);\n    };\n\n\n    // Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\n    this.makeHullPresorted = function (points) {\n        if (points.length <= 1)\n            return points.slice();\n\n        // Andrew's monotone chain algorithm. Positive y coordinates correspond to \"up\"\n        // as per the mathematical convention, instead of \"down\" as per the computer\n        // graphics convention. This doesn't affect the correctness of the result.\n\n        var upperHull = [];\n        for (var i = 0; i < points.length; i++) {\n            var p = points[i];\n            while (upperHull.length >= 2) {\n                var q = upperHull[upperHull.length - 1];\n                var r = upperHull[upperHull.length - 2];\n                if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n                    upperHull.pop();\n                else\n                    break;\n            }\n            upperHull.push(p);\n        }\n        upperHull.pop();\n\n        var lowerHull = [];\n        for (var i = points.length - 1; i >= 0; i--) {\n            var p = points[i];\n            while (lowerHull.length >= 2) {\n                var q = lowerHull[lowerHull.length - 1];\n                var r = lowerHull[lowerHull.length - 2];\n                if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n                    lowerHull.pop();\n                else\n                    break;\n            }\n            lowerHull.push(p);\n        }\n        lowerHull.pop();\n\n        if (upperHull.length == 1 && lowerHull.length == 1 && upperHull[0].x == lowerHull[0].x && upperHull[0].y == lowerHull[0].y)\n            return upperHull;\n        else\n            return upperHull.concat(lowerHull);\n    };\n\n\n    this.POINT_COMPARATOR = function (a, b) {\n        if (a.x < b.x)\n            return -1;\n        else if (a.x > b.x)\n            return +1;\n        else if (a.y < b.y)\n            return -1;\n        else if (a.y > b.y)\n            return +1;\n        else\n            return 0;\n    };\n\n};\nmodule.exports = convexhull\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n","'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","\"use strict\"\n\nmodule.exports = twoProduct\n\nvar SPLITTER = +(Math.pow(2, 27) + 1.0)\n\nfunction twoProduct(a, b, result) {\n  var x = a * b\n\n  var c = SPLITTER * a\n  var abig = c - a\n  var ahi = c - abig\n  var alo = a - ahi\n\n  var d = SPLITTER * b\n  var bbig = d - b\n  var bhi = d - bbig\n  var blo = b - bhi\n\n  var err1 = x - (ahi * bhi)\n  var err2 = err1 - (alo * bhi)\n  var err3 = err2 - (ahi * blo)\n\n  var y = alo * blo - err3\n\n  if(result) {\n    result[0] = y\n    result[1] = x\n    return result\n  }\n\n  return [ y, x ]\n}","\"use strict\"\n\nmodule.exports = linearExpansionSum\n\n//Easy case: Add two scalars\nfunction scalarScalar(a, b) {\n  var x = a + b\n  var bv = x - a\n  var av = x - bv\n  var br = b - bv\n  var ar = a - av\n  var y = ar + br\n  if(y) {\n    return [y, x]\n  }\n  return [x]\n}\n\nfunction linearExpansionSum(e, f) {\n  var ne = e.length|0\n  var nf = f.length|0\n  if(ne === 1 && nf === 1) {\n    return scalarScalar(e[0], f[0])\n  }\n  var n = ne + nf\n  var g = new Array(n)\n  var count = 0\n  var eptr = 0\n  var fptr = 0\n  var abs = Math.abs\n  var ei = e[eptr]\n  var ea = abs(ei)\n  var fi = f[fptr]\n  var fa = abs(fi)\n  var a, b\n  if(ea < fa) {\n    b = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    b = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n      fa = abs(fi)\n    }\n  }\n  if((eptr < ne && ea < fa) || (fptr >= nf)) {\n    a = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    a = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n      fa = abs(fi)\n    }\n  }\n  var x = a + b\n  var bv = x - a\n  var y = b - bv\n  var q0 = y\n  var q1 = x\n  var _x, _bv, _av, _br, _ar\n  while(eptr < ne && fptr < nf) {\n    if(ea < fa) {\n      a = ei\n      eptr += 1\n      if(eptr < ne) {\n        ei = e[eptr]\n        ea = abs(ei)\n      }\n    } else {\n      a = fi\n      fptr += 1\n      if(fptr < nf) {\n        fi = f[fptr]\n        fa = abs(fi)\n      }\n    }\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n  }\n  while(eptr < ne) {\n    a = ei\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n    }\n  }\n  while(fptr < nf) {\n    a = fi\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    } \n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n    }\n  }\n  if(q0) {\n    g[count++] = q0\n  }\n  if(q1) {\n    g[count++] = q1\n  }\n  if(!count) {\n    g[count++] = 0.0  \n  }\n  g.length = count\n  return g\n}","\"use strict\"\n\nmodule.exports = fastTwoSum\n\nfunction fastTwoSum(a, b, result) {\n\tvar x = a + b\n\tvar bv = x - a\n\tvar av = x - bv\n\tvar br = b - bv\n\tvar ar = a - av\n\tif(result) {\n\t\tresult[0] = ar + br\n\t\tresult[1] = x\n\t\treturn result\n\t}\n\treturn [ar+br, x]\n}","\"use strict\"\n\nvar twoProduct = require(\"two-product\")\nvar twoSum = require(\"two-sum\")\n\nmodule.exports = scaleLinearExpansion\n\nfunction scaleLinearExpansion(e, scale) {\n  var n = e.length\n  if(n === 1) {\n    var ts = twoProduct(e[0], scale)\n    if(ts[0]) {\n      return ts\n    }\n    return [ ts[1] ]\n  }\n  var g = new Array(2 * n)\n  var q = [0.1, 0.1]\n  var t = [0.1, 0.1]\n  var count = 0\n  twoProduct(e[0], scale, q)\n  if(q[0]) {\n    g[count++] = q[0]\n  }\n  for(var i=1; i<n; ++i) {\n    twoProduct(e[i], scale, t)\n    var pq = q[1]\n    twoSum(pq, t[0], q)\n    if(q[0]) {\n      g[count++] = q[0]\n    }\n    var a = t[1]\n    var b = q[1]\n    var x = a + b\n    var bv = x - a\n    var y = b - bv\n    q[1] = x\n    if(y) {\n      g[count++] = y\n    }\n  }\n  if(q[1]) {\n    g[count++] = q[1]\n  }\n  if(count === 0) {\n    g[count++] = 0.0\n  }\n  g.length = count\n  return g\n}","\"use strict\"\n\nmodule.exports = robustSubtract\n\n//Easy case: Add two scalars\nfunction scalarScalar(a, b) {\n  var x = a + b\n  var bv = x - a\n  var av = x - bv\n  var br = b - bv\n  var ar = a - av\n  var y = ar + br\n  if(y) {\n    return [y, x]\n  }\n  return [x]\n}\n\nfunction robustSubtract(e, f) {\n  var ne = e.length|0\n  var nf = f.length|0\n  if(ne === 1 && nf === 1) {\n    return scalarScalar(e[0], -f[0])\n  }\n  var n = ne + nf\n  var g = new Array(n)\n  var count = 0\n  var eptr = 0\n  var fptr = 0\n  var abs = Math.abs\n  var ei = e[eptr]\n  var ea = abs(ei)\n  var fi = -f[fptr]\n  var fa = abs(fi)\n  var a, b\n  if(ea < fa) {\n    b = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    b = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n      fa = abs(fi)\n    }\n  }\n  if((eptr < ne && ea < fa) || (fptr >= nf)) {\n    a = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    a = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n      fa = abs(fi)\n    }\n  }\n  var x = a + b\n  var bv = x - a\n  var y = b - bv\n  var q0 = y\n  var q1 = x\n  var _x, _bv, _av, _br, _ar\n  while(eptr < ne && fptr < nf) {\n    if(ea < fa) {\n      a = ei\n      eptr += 1\n      if(eptr < ne) {\n        ei = e[eptr]\n        ea = abs(ei)\n      }\n    } else {\n      a = fi\n      fptr += 1\n      if(fptr < nf) {\n        fi = -f[fptr]\n        fa = abs(fi)\n      }\n    }\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n  }\n  while(eptr < ne) {\n    a = ei\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n    }\n  }\n  while(fptr < nf) {\n    a = fi\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    } \n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n    }\n  }\n  if(q0) {\n    g[count++] = q0\n  }\n  if(q1) {\n    g[count++] = q1\n  }\n  if(!count) {\n    g[count++] = 0.0  \n  }\n  g.length = count\n  return g\n}","\"use strict\"\n\nvar twoProduct = require(\"two-product\")\nvar robustSum = require(\"robust-sum\")\nvar robustScale = require(\"robust-scale\")\nvar robustSubtract = require(\"robust-subtract\")\n\nvar NUM_EXPAND = 5\n\nvar EPSILON     = 1.1102230246251565e-16\nvar ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON\nvar ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON\n\nfunction cofactor(m, c) {\n  var result = new Array(m.length-1)\n  for(var i=1; i<m.length; ++i) {\n    var r = result[i-1] = new Array(m.length-1)\n    for(var j=0,k=0; j<m.length; ++j) {\n      if(j === c) {\n        continue\n      }\n      r[k++] = m[i][j]\n    }\n  }\n  return result\n}\n\nfunction matrix(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = new Array(n)\n    for(var j=0; j<n; ++j) {\n      result[i][j] = [\"m\", j, \"[\", (n-i-1), \"]\"].join(\"\")\n    }\n  }\n  return result\n}\n\nfunction sign(n) {\n  if(n & 1) {\n    return \"-\"\n  }\n  return \"\"\n}\n\nfunction generateSum(expr) {\n  if(expr.length === 1) {\n    return expr[0]\n  } else if(expr.length === 2) {\n    return [\"sum(\", expr[0], \",\", expr[1], \")\"].join(\"\")\n  } else {\n    var m = expr.length>>1\n    return [\"sum(\", generateSum(expr.slice(0, m)), \",\", generateSum(expr.slice(m)), \")\"].join(\"\")\n  }\n}\n\nfunction determinant(m) {\n  if(m.length === 2) {\n    return [[\"sum(prod(\", m[0][0], \",\", m[1][1], \"),prod(-\", m[0][1], \",\", m[1][0], \"))\"].join(\"\")]\n  } else {\n    var expr = []\n    for(var i=0; i<m.length; ++i) {\n      expr.push([\"scale(\", generateSum(determinant(cofactor(m, i))), \",\", sign(i), m[0][i], \")\"].join(\"\"))\n    }\n    return expr\n  }\n}\n\nfunction orientation(n) {\n  var pos = []\n  var neg = []\n  var m = matrix(n)\n  var args = []\n  for(var i=0; i<n; ++i) {\n    if((i&1)===0) {\n      pos.push.apply(pos, determinant(cofactor(m, i)))\n    } else {\n      neg.push.apply(neg, determinant(cofactor(m, i)))\n    }\n    args.push(\"m\" + i)\n  }\n  var posExpr = generateSum(pos)\n  var negExpr = generateSum(neg)\n  var funcName = \"orientation\" + n + \"Exact\"\n  var code = [\"function \", funcName, \"(\", args.join(), \"){var p=\", posExpr, \",n=\", negExpr, \",d=sub(p,n);\\\nreturn d[d.length-1];};return \", funcName].join(\"\")\n  var proc = new Function(\"sum\", \"prod\", \"scale\", \"sub\", code)\n  return proc(robustSum, twoProduct, robustScale, robustSubtract)\n}\n\nvar orientation3Exact = orientation(3)\nvar orientation4Exact = orientation(4)\n\nvar CACHED = [\n  function orientation0() { return 0 },\n  function orientation1() { return 0 },\n  function orientation2(a, b) { \n    return b[0] - a[0]\n  },\n  function orientation3(a, b, c) {\n    var l = (a[1] - c[1]) * (b[0] - c[0])\n    var r = (a[0] - c[0]) * (b[1] - c[1])\n    var det = l - r\n    var s\n    if(l > 0) {\n      if(r <= 0) {\n        return det\n      } else {\n        s = l + r\n      }\n    } else if(l < 0) {\n      if(r >= 0) {\n        return det\n      } else {\n        s = -(l + r)\n      }\n    } else {\n      return det\n    }\n    var tol = ERRBOUND3 * s\n    if(det >= tol || det <= -tol) {\n      return det\n    }\n    return orientation3Exact(a, b, c)\n  },\n  function orientation4(a,b,c,d) {\n    var adx = a[0] - d[0]\n    var bdx = b[0] - d[0]\n    var cdx = c[0] - d[0]\n    var ady = a[1] - d[1]\n    var bdy = b[1] - d[1]\n    var cdy = c[1] - d[1]\n    var adz = a[2] - d[2]\n    var bdz = b[2] - d[2]\n    var cdz = c[2] - d[2]\n    var bdxcdy = bdx * cdy\n    var cdxbdy = cdx * bdy\n    var cdxady = cdx * ady\n    var adxcdy = adx * cdy\n    var adxbdy = adx * bdy\n    var bdxady = bdx * ady\n    var det = adz * (bdxcdy - cdxbdy) \n            + bdz * (cdxady - adxcdy)\n            + cdz * (adxbdy - bdxady)\n    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)\n                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)\n                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)\n    var tol = ERRBOUND4 * permanent\n    if ((det > tol) || (-det > tol)) {\n      return det\n    }\n    return orientation4Exact(a,b,c,d)\n  }\n]\n\nfunction slowOrient(args) {\n  var proc = CACHED[args.length]\n  if(!proc) {\n    proc = CACHED[args.length] = orientation(args.length)\n  }\n  return proc.apply(undefined, args)\n}\n\nfunction generateOrientationProc() {\n  while(CACHED.length <= NUM_EXPAND) {\n    CACHED.push(orientation(CACHED.length))\n  }\n  var args = []\n  var procArgs = [\"slow\"]\n  for(var i=0; i<=NUM_EXPAND; ++i) {\n    args.push(\"a\" + i)\n    procArgs.push(\"o\" + i)\n  }\n  var code = [\n    \"function getOrientation(\", args.join(), \"){switch(arguments.length){case 0:case 1:return 0;\"\n  ]\n  for(var i=2; i<=NUM_EXPAND; ++i) {\n    code.push(\"case \", i, \":return o\", i, \"(\", args.slice(0, i).join(), \");\")\n  }\n  code.push(\"}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation\")\n  procArgs.push(code.join(\"\"))\n\n  var proc = Function.apply(undefined, procArgs)\n  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))\n  for(var i=0; i<=NUM_EXPAND; ++i) {\n    module.exports[i] = CACHED[i]\n  }\n}\n\ngenerateOrientationProc()","'use strict'\n\nmodule.exports = monotoneConvexHull2D\n\nvar orient = require('robust-orientation')[3]\n\nfunction monotoneConvexHull2D(points) {\n  var n = points.length\n\n  if(n < 3) {\n    var result = new Array(n)\n    for(var i=0; i<n; ++i) {\n      result[i] = i\n    }\n\n    if(n === 2 &&\n       points[0][0] === points[1][0] &&\n       points[0][1] === points[1][1]) {\n      return [0]\n    }\n\n    return result\n  }\n\n  //Sort point indices along x-axis\n  var sorted = new Array(n)\n  for(var i=0; i<n; ++i) {\n    sorted[i] = i\n  }\n  sorted.sort(function(a,b) {\n    var d = points[a][0]-points[b][0]\n    if(d) {\n      return d\n    }\n    return points[a][1] - points[b][1]\n  })\n\n  //Construct upper and lower hulls\n  var lower = [sorted[0], sorted[1]]\n  var upper = [sorted[0], sorted[1]]\n\n  for(var i=2; i<n; ++i) {\n    var idx = sorted[i]\n    var p   = points[idx]\n\n    //Insert into lower list\n    var m = lower.length\n    while(m > 1 && orient(\n        points[lower[m-2]], \n        points[lower[m-1]], \n        p) <= 0) {\n      m -= 1\n      lower.pop()\n    }\n    lower.push(idx)\n\n    //Insert into upper list\n    m = upper.length\n    while(m > 1 && orient(\n        points[upper[m-2]], \n        points[upper[m-1]], \n        p) >= 0) {\n      m -= 1\n      upper.pop()\n    }\n    upper.push(idx)\n  }\n\n  //Merge lists together\n  var result = new Array(upper.length + lower.length - 2)\n  var ptr    = 0\n  for(var i=0, nl=lower.length; i<nl; ++i) {\n    result[ptr++] = lower[i]\n  }\n  for(var j=upper.length-2; j>0; --j) {\n    result[ptr++] = upper[j]\n  }\n\n  //Return result\n  return result\n}","'use strict';\n\nmodule.exports = TinyQueue;\nmodule.exports.default = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n\n        var top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var halfLength = this.length >> 1;\n        var item = data[pos];\n\n        while (pos < halfLength) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n","module.exports = function (point, vs) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n    \n    var x = point[0], y = point[1];\n    \n    var inside = false;\n    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n        var xi = vs[i][0], yi = vs[i][1];\n        var xj = vs[j][0], yj = vs[j][1];\n        \n        var intersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    \n    return inside;\n};\n","'use strict';\n\nvar rbush = require('rbush');\nvar convexHull = require('monotone-convex-hull-2d');\nvar Queue = require('tinyqueue');\nvar pointInPolygon = require('point-in-polygon');\nvar orient = require('robust-orientation')[3];\n\nmodule.exports = concaveman;\nmodule.exports.default = concaveman;\n\nfunction concaveman(points, concavity, lengthThreshold) {\n    // a relative measure of concavity; higher value means simpler hull\n    concavity = Math.max(0, concavity === undefined ? 2 : concavity);\n\n    // when a segment goes below this length threshold, it won't be drilled down further\n    lengthThreshold = lengthThreshold || 0;\n\n    // start with a convex hull of the points\n    var hull = fastConvexHull(points);\n\n    // index the points with an R-tree\n    var tree = rbush(16, ['[0]', '[1]', '[0]', '[1]']).load(points);\n\n    // turn the convex hull into a linked list and populate the initial edge queue with the nodes\n    var queue = [];\n    for (var i = 0, last; i < hull.length; i++) {\n        var p = hull[i];\n        tree.remove(p);\n        last = insertNode(p, last);\n        queue.push(last);\n    }\n\n    // index the segments with an R-tree (for intersection checks)\n    var segTree = rbush(16);\n    for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));\n\n    var sqConcavity = concavity * concavity;\n    var sqLenThreshold = lengthThreshold * lengthThreshold;\n\n    // process edges one by one\n    while (queue.length) {\n        var node = queue.shift();\n        var a = node.p;\n        var b = node.next.p;\n\n        // skip the edge if it's already short enough\n        var sqLen = getSqDist(a, b);\n        if (sqLen < sqLenThreshold) continue;\n\n        var maxSqLen = sqLen / sqConcavity;\n\n        // find the best connection point for the current edge to flex inward to\n        p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);\n\n        // if we found a connection and it satisfies our concavity measure\n        if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\n            // connect the edge endpoints through this point and add 2 new edges to the queue\n            queue.push(node);\n            queue.push(insertNode(p, node));\n\n            // update point and segment indexes\n            tree.remove(p);\n            segTree.remove(node);\n            segTree.insert(updateBBox(node));\n            segTree.insert(updateBBox(node.next));\n        }\n    }\n\n    // convert the resulting hull linked list to an array of points\n    node = last;\n    var concave = [];\n    do {\n        concave.push(node.p);\n        node = node.next;\n    } while (node !== last);\n\n    concave.push(node.p);\n\n    return concave;\n}\n\nfunction findCandidate(tree, a, b, c, d, maxDist, segTree) {\n    var queue = new Queue(null, compareDist);\n    var node = tree.data;\n\n    // search through the point R-tree with a depth-first search using a priority queue\n    // in the order of distance to the edge (b, c)\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n\n            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\n            if (dist > maxDist) continue; // skip the node if it's farther than we ever need\n\n            queue.push({\n                node: child,\n                dist: dist\n            });\n        }\n\n        while (queue.length && !queue.peek().node.children) {\n            var item = queue.pop();\n            var p = item.node;\n\n            // skip all points that are as close to adjacent edges (a,b) and (c,d),\n            // and points that would introduce self-intersections when connected\n            var d0 = sqSegDist(p, a, b);\n            var d1 = sqSegDist(p, c, d);\n            if (item.dist < d0 && item.dist < d1 &&\n                noIntersections(b, p, segTree) &&\n                noIntersections(c, p, segTree)) return p;\n        }\n\n        node = queue.pop();\n        if (node) node = node.node;\n    }\n\n    return null;\n}\n\nfunction compareDist(a, b) {\n    return a.dist - b.dist;\n}\n\n// square distance from a segment bounding box to the given one\nfunction sqSegBoxDist(a, b, bbox) {\n    if (inside(a, bbox) || inside(b, bbox)) return 0;\n    var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);\n    if (d1 === 0) return 0;\n    var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);\n    if (d2 === 0) return 0;\n    var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);\n    if (d3 === 0) return 0;\n    var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);\n    if (d4 === 0) return 0;\n    return Math.min(d1, d2, d3, d4);\n}\n\nfunction inside(a, bbox) {\n    return a[0] >= bbox.minX &&\n           a[0] <= bbox.maxX &&\n           a[1] >= bbox.minY &&\n           a[1] <= bbox.maxY;\n}\n\n// check if the edge (a,b) doesn't intersect any other edges\nfunction noIntersections(a, b, segTree) {\n    var minX = Math.min(a[0], b[0]);\n    var minY = Math.min(a[1], b[1]);\n    var maxX = Math.max(a[0], b[0]);\n    var maxY = Math.max(a[1], b[1]);\n\n    var edges = segTree.search({minX: minX, minY: minY, maxX: maxX, maxY: maxY});\n    for (var i = 0; i < edges.length; i++) {\n        if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\n    }\n    return true;\n}\n\n// check if the edges (p1,q1) and (p2,q2) intersect\nfunction intersects(p1, q1, p2, q2) {\n    return p1 !== q2 && q1 !== p2 &&\n        orient(p1, q1, p2) > 0 !== orient(p1, q1, q2) > 0 &&\n        orient(p2, q2, p1) > 0 !== orient(p2, q2, q1) > 0;\n}\n\n// update the bounding box of a node's edge\nfunction updateBBox(node) {\n    var p1 = node.p;\n    var p2 = node.next.p;\n    node.minX = Math.min(p1[0], p2[0]);\n    node.minY = Math.min(p1[1], p2[1]);\n    node.maxX = Math.max(p1[0], p2[0]);\n    node.maxY = Math.max(p1[1], p2[1]);\n    return node;\n}\n\n// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\nfunction fastConvexHull(points) {\n    var left = points[0];\n    var top = points[0];\n    var right = points[0];\n    var bottom = points[0];\n\n    // find the leftmost, rightmost, topmost and bottommost points\n    for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        if (p[0] < left[0]) left = p;\n        if (p[0] > right[0]) right = p;\n        if (p[1] < top[1]) top = p;\n        if (p[1] > bottom[1]) bottom = p;\n    }\n\n    // filter out points that are inside the resulting quadrilateral\n    var cull = [left, top, right, bottom];\n    var filtered = cull.slice();\n    for (i = 0; i < points.length; i++) {\n        if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);\n    }\n\n    // get convex hull around the filtered points\n    var indices = convexHull(filtered);\n\n    // return the hull as array of points (rather than indices)\n    var hull = [];\n    for (i = 0; i < indices.length; i++) hull.push(filtered[indices[i]]);\n    return hull;\n}\n\n// create a new node in a doubly linked list\nfunction insertNode(p, prev) {\n    var node = {\n        p: p,\n        prev: null,\n        next: null,\n        minX: 0,\n        minY: 0,\n        maxX: 0,\n        maxY: 0\n    };\n\n    if (!prev) {\n        node.prev = node;\n        node.next = node;\n\n    } else {\n        node.next = prev.next;\n        node.prev = prev;\n        prev.next.prev = node;\n        prev.next = node;\n    }\n    return node;\n}\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1[0] - p2[0],\n        dy = p1[1] - p2[1];\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction sqSegDist(p, p1, p2) {\n\n    var x = p1[0],\n        y = p1[1],\n        dx = p2[0] - x,\n        dy = p2[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2[0];\n            y = p2[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p[0] - x;\n    dy = p[1] - y;\n\n    return dx * dx + dy * dy;\n}\n\n// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\nfunction sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\n    var ux = x1 - x0;\n    var uy = y1 - y0;\n    var vx = x3 - x2;\n    var vy = y3 - y2;\n    var wx = x0 - x2;\n    var wy = y0 - y2;\n    var a = ux * ux + uy * uy;\n    var b = ux * vx + uy * vy;\n    var c = vx * vx + vy * vy;\n    var d = ux * wx + uy * wy;\n    var e = vx * wx + vy * wy;\n    var D = a * c - b * b;\n\n    var sc, sN, tc, tN;\n    var sD = D;\n    var tD = D;\n\n    if (D === 0) {\n        sN = 0;\n        sD = 1;\n        tN = e;\n        tD = c;\n    } else {\n        sN = b * e - c * d;\n        tN = a * e - b * d;\n        if (sN < 0) {\n            sN = 0;\n            tN = e;\n            tD = c;\n        } else if (sN > sD) {\n            sN = sD;\n            tN = e + b;\n            tD = c;\n        }\n    }\n\n    if (tN < 0.0) {\n        tN = 0.0;\n        if (-d < 0.0) sN = 0.0;\n        else if (-d > a) sN = sD;\n        else {\n            sN = -d;\n            sD = a;\n        }\n    } else if (tN > tD) {\n        tN = tD;\n        if ((-d + b) < 0.0) sN = 0;\n        else if (-d + b > a) sN = sD;\n        else {\n            sN = -d + b;\n            sD = a;\n        }\n    }\n\n    sc = sN === 0 ? 0 : sN / sD;\n    tc = tN === 0 ? 0 : tN / tD;\n\n    var cx = (1 - sc) * x0 + sc * x1;\n    var cy = (1 - sc) * y0 + sc * y1;\n    var cx2 = (1 - tc) * x2 + tc * x3;\n    var cy2 = (1 - tc) * y2 + tc * y3;\n    var dx = cx2 - cx;\n    var dy = cy2 - cy;\n\n    return dx * dx + dy * dy;\n}\n","const convexhull = require('./convec_hull')\nconst concaveman = require('concaveman')\n\n\nfunction splitByTimestamp(coordinates) {\n    let coordinatesByTime = {}\n    coordinates.forEach(c => {\n        let time = new Date(c.timestamp)\n        let h = time.getHours()\n        let timeName = h.toString() + ':00-' + h.toString() + ':59'\n        if (!coordinatesByTime[timeName]) {\n            coordinatesByTime[timeName] = []\n        }\n        coordinatesByTime[timeName].push(c)\n    });\n    return coordinatesByTime\n}\n\nfunction measure(coord1, coord2) {  // generally used geo measurement function\n    let lat1 = coord1.lat\n    let lon1 = coord1.lng\n    let lat2 = coord2.lat\n    let lon2 = coord2.lng\n\n    var R = 6378.137; // Radius of earth in KM\n    var dLat = lat2 * Math.PI / 180 - lat1 * Math.PI / 180;\n    var dLon = lon2 * Math.PI / 180 - lon1 * Math.PI / 180;\n    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n        Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    var d = R * c;\n    return d * 1000; // meters\n}\n\n\n\nfunction coordinateIsIn(coordinate, coordinateGroups) {\n    let index = -1\n    coordinateGroups.forEach((polygon, i) => {\n        if (polygon.includes(coordinate)) {\n            index = i\n            return\n        }\n    });\n    return index\n}\n\nfunction groupCoordinatesByDistance(coordinates, allowedDistance) {\n    let coordinateGroups = []\n    for (let i = 0; i < coordinates.length; i++) {\n        let c = coordinates\n        let iPolygonIndex = coordinateIsIn(c[i], coordinateGroups)\n        if (iPolygonIndex < 0) {\n            coordinateGroups.push([c[i]])\n            iPolygonIndex = coordinateGroups.length - 1\n        }\n        for (let j = 0; j < coordinates.length; j++) {\n            if (!(i === j)) {\n                let distance = measure(c[i].location, c[j].location)\n                if (distance <= allowedDistance) {\n                    let jPolygonIndex = coordinateIsIn(c[j], coordinateGroups)\n                    if (jPolygonIndex < 0) {\n                        coordinateGroups[iPolygonIndex].push(c[j])\n                    } else if (jPolygonIndex !== iPolygonIndex) {\n                        let newArr = coordinateGroups[iPolygonIndex].concat(coordinateGroups[jPolygonIndex])\n                        coordinateGroups.splice(iPolygonIndex, 1)\n                        coordinateGroups.splice(jPolygonIndex, 1)\n                        coordinateGroups.push(newArr)\n                        iPolygonIndex = coordinateGroups.length - 1\n                        jPolygonIndex = iPolygonIndex\n                    }\n                }\n            }\n        }\n    }\n    return coordinateGroups\n}\n\nfunction getCoordinatesInXY(coordinates) {\n    let coordinatesXY = []\n    coordinates.forEach(c => {\n        coordinatesXY.push({\n            x: c.location.lat,\n            y: c.location.lng\n        })\n    });\n    return coordinatesXY\n}\n\nfunction getXYCoordinatesInLatLng(coordinates) {\n    let coordinatesLatLng = []\n    coordinates.forEach(c => {\n        coordinatesLatLng.push({\n            lat: c.x,\n            lng: c.y\n        })\n    });\n    return coordinatesLatLng\n}\n\nfunction calculatePolygon(coordinates) {\n    let coordinatesXY = getCoordinatesInXY(coordinates)\n    // let polygonXY = convexhull.makeHull(coordinatesXY)\n    let polygonXY = concaveman(coordinatesXY)\n    let polygonLatLng = getXYCoordinatesInLatLng(polygonXY)\n    return polygonLatLng\n}\n\nfunction calculatePolygonsFromCoordinateGroups(coordinateGroups) {\n    let polygons = []\n    coordinateGroups.forEach(group => {\n        polygons.push(calculatePolygon(group))\n    });\n    return polygons\n}\n\nfunction getPolygon(coordinates, allowedDistance) {\n    let newCoordinates = JSON.parse(JSON.stringify(coordinates))\n    let groups = groupCoordinatesByDistance(newCoordinates, allowedDistance)\n    let polygons = calculatePolygonsFromCoordinateGroups(groups)\n    return polygons\n}\n\n\n\nfunction run(coordinates, allowedDistance) {\n    let coordinatesByTime = splitByTimestamp(coordinates)\n    let polygons = {}\n    for (let key in coordinatesByTime) {\n        polygons[key] = getPolygon(coordinatesByTime[key], allowedDistance)\n    }\n    return polygons\n}\n\nmodule.exports = run","require('dotenv').config()\nconst loadGoogleMapsApi = require('load-google-maps-api')\nlet fs = require('fs')\nlet polygons = require('./calculatePolygons')\n\nlet cords_full = fs.readFileSync('./assets/cords_full.json', 'utf8')\nlet one_coordinates = fs.readFileSync('./assets/chords_one.json', 'utf8')\n\nlet dataset_1 = JSON.parse(cords_full)\nlet searchRadiusButton = document.getElementById('searchRadius')\nlet arr = []\nlet map, googleMaps, heatmap\nlet radius = 50\n\n\n\n// const page = await import('./calculatePolygons')\n\n\nconst covertToGoogleMapsCords = (data) => {\n  return data.map((cord) => {\n    return {\n      location: new window.google.maps.LatLng({\n        lat: cord.location.lat,\n        lng: cord.location.lng,\n      }),\n      weight: cord.weight,\n    }\n  })\n}\n\n/* \nCreate map when DOM is loaded.\nSet up listener for adding new posotions to heatmap layer.\n*/\n\nconst initMap = function _initMap() {\n  document.addEventListener('DOMContentLoaded', () => {\n    let mapElement = document.getElementById('map')\n\n    loadGoogleMapsApi({\n      key: process.env.GOOGLE_MAPS_API_KEY,\n      libraries: ['visualization'],\n    }).then((google) => {\n      googleMaps = google\n\n      map = new googleMaps.Map(mapElement, {\n        center: {\n          lat: 56.657081713112085,\n          lng: 16.321899075213206,\n        },\n        zoom: 19,\n        zoomControl: false,\n        scaleControl: false,\n        scrollwheel: false,\n        disableDoubleClickZoom: true,\n        mapTypeId: 'satellite',\n      })\n\n      // Polygon-layer\n      createPolygonLayer(dataset_1)\n\n      // Circle-layer\n      let copyOfDataSet = [...dataset_1]\n      let colorizedDataset = divideColorToCordordinates(copyOfDataSet)\n      createCircelsLayer(colorizedDataset)\n\n      // Heatmap-layer  \n      createHeatmapLayer(covertToGoogleMapsCords(calculateWeight(dataset_1)))\n      writePositionsToJSONByClick()\n    })\n  })\n}\n\n\nconst calculateWeight = (stdCoordinates) => {\n  let crds = JSON.parse(JSON.stringify(stdCoordinates))\n\n  crds.sort(function (a, b) {\n    return a.timestamp - b.timestamp\n  })\n\n  if (crds.length > 1) {\n    let diff = crds[crds.length - 1].timestamp - crds[0].timestamp\n    let i = 1\n    crds.forEach((element) => {\n      let percent = ((element.timestamp - crds[0].timestamp) / diff) * 100\n      element.weight = parseFloat(percent.toFixed(1)) + 1\n    })\n  }\n\n  return crds\n}\n\n\n/* \nCreate Polygon with based on the given parameters. \n*/\n\nconst creatPolygon = (coordinates, sColor, sOpacity, weight, fColor, fOpacity) => {\n\n  var polygonLayer = new google.maps.Polygon({\n    paths: coordinates,\n    strokeColor: sColor,\n    strokeOpacity: sOpacity,\n    strokeWeight: weight,\n    fillColor: fColor,\n    fillOpacity: fOpacity,\n    draggable: false\n  });\n\n  return polygonLayer\n}\n\n/* \nUses creatPolygon() to creates a new separate polygon for every array returned by polygons() method. \n*/\n\nconst createPolygonLayer = (coordinates) => {\n  let allCords = polygons(coordinates, 4)['10:00-10:59']\n  allCords.forEach(cordsArray => {\n    let polygon = creatPolygon(cordsArray, 'rgba(0, 0, 255, 1)', 1.2, 2, 'rgba(255, 0, 0, 1)', .85)\n    polygon.setMap(map);\n  });\n}\n\n\n/* \nCreate Heatmap-layer with coordinates array. \n*/\n\nconst createHeatmapLayer = (coordinates) => {\n\n  heatmap = new googleMaps.visualization.HeatmapLayer({\n    data: coordinates,\n  })\n\n  heatmap.setMap(map)\n\n  heatmap.set('radius', heatmap.get('radius') ? radius : radius)\n\n  let gradient = [\n    'rgba(0, 0, 255, 0)',\n    'rgba(0, 0, 255, 1)',\n    'rgba(55, 0, 200, 1)',\n    'rgba(125, 0, 120, 1)',\n    'rgba(200, 0, 55, 1)',\n    'rgba(255, 0, 0, 1)',\n  ]\n\n  heatmap.set('gradient', heatmap.get('gradient') ? null : gradient)\n\n}\n\n\nconst divideColorToCordordinates = (coordinates) => {\n\n  coordinates.sort(function (a, b) {\n    return a.timestamp - b.timestamp\n  })\n\n\n  let dividedArray = splitToChunks(coordinates, 6)\n\n  // TODO: snygga till dessa foreach till en nestad foreach\n  dividedArray[0].forEach(element => {\n    element.color = 'rgba(0, 0, 255, 0.5)'\n  });\n\n  dividedArray[1].forEach(element => {\n    element.color = 'rgba(0, 0, 255, 1)'\n  });\n\n  dividedArray[2].forEach(element => {\n    element.color = 'rgba(55, 0, 200, 1)'\n  });\n\n  dividedArray[3].forEach(element => {\n    element.color = 'rgba(125, 0, 120, 1)'\n  });\n\n  dividedArray[4].forEach(element => {\n    element.color = 'rgba(200, 0, 55, 1)'\n  });\n\n  dividedArray[5].forEach(element => {\n    element.color = 'rgba(255, 0, 0, 1)'\n  });\n\n  return dividedArray\n\n}\n\n\n\nconst splitToChunks = (array, parts) => {\n  let result = [];\n  for (let i = parts; i > 0; i--) {\n    result.push(array.splice(0, Math.ceil(array.length / i)));\n  }\n  return result;\n}\n\n\nconst createCircelsLayer = (coordinates) => {\n\n  coordinates.forEach(coordinates => {\n\n    for (var coord in coordinates) {\n      var coordCircle = new window.google.maps.Circle({\n        strokeColor: '#FF0000',\n        strokeOpacity: 0.2,\n        strokeWeight: 2,\n        fillColor: coordinates[coord].color,\n        fillOpacity: 0.35,\n        map: map,\n        center: coordinates[coord].location,\n        radius: Math.sin(coordinates[coord].timestamp) * 2 // SKRADIE - TODO: fixa vettigt skradie algorithm\n      });\n    }\n  });\n}\n\nconst changeRadius = () => {\n  searchRadiusButton.addEventListener('click', () => {\n    let inputValue = document.querySelector('.input').value\n    if (inputValue <= 100 && inputValue > 0) {\n      radius = inputValue\n      heatmap.set('radius', heatmap.get('radius') ? radius : radius)\n    }\n  })\n}\n\n/* \nAppends the \"click-positions\" longiture & latitude to the coordinates array.\n*/\n\nconst writePositionsToJSONByClick = () => {\n  googleMaps.event.addListener(map, 'click', (event) => {\n    arr.push({\n      location: new window.google.maps.LatLng({\n        lat: event.latLng.lat(),\n        lng: event.latLng.lng(),\n      }),\n      weight: 1,\n      timestamp: Date.now(),\n    })\n    heatmap.setMap(null)\n    let data = calculateWeight(arr)\n    let coordinates = covertToGoogleMapsCords(data)\n    createHeatmapLayer(coordinates)\n  })\n}\n\ninitMap()\nchangeRadius()\n"]}