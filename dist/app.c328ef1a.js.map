{"version":3,"sources":["../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/process/browser.js","../../../../usr/local/lib/node_modules/parcel-bundler/node_modules/path-browserify/index.js","node_modules/dotenv/lib/main.js","node_modules/load-google-maps-api/index.js","convec_hull.js","node_modules/quickselect/quickselect.js","node_modules/rbush/index.js","node_modules/two-product/two-product.js","node_modules/robust-sum/robust-sum.js","node_modules/two-sum/two-sum.js","node_modules/robust-scale/robust-scale.js","node_modules/robust-subtract/robust-diff.js","node_modules/robust-orientation/orientation.js","node_modules/monotone-convex-hull-2d/index.js","node_modules/tinyqueue/index.js","node_modules/point-in-polygon/index.js","node_modules/concaveman/index.js","calculatePolygons.js","app.js"],"names":["process","module","exports","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","setTimeout","e","clearTimeout","runTimeout","fun","call","runClearTimeout","marker","queue","draining","currentQueue","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","nextTick","args","Array","arguments","i","push","Item","array","prototype","apply","title","env","argv","version","versions","noop","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","fs","require","path","log","message","console","NEWLINE","RE_INI_KEY_VAL","RE_NEWLINES","NEWLINES_MATCH","parse","src","options","debug","Boolean","obj","toString","split","forEach","line","idx","keyValueArr","match","key","val","end","isDoubleQuoted","isSingleQuoted","substring","replace","trim","config","dotenvPath","resolve","encoding","parsed","readFileSync","Object","keys","hasOwnProperty","error","convexhull","makeHull","points","newPoints","slice","sort","POINT_COMPARATOR","makeHullPresorted","upperHull","p","q","r","x","y","pop","lowerHull","a","b","concaveman","splitByTimestamp","coordinates","coordinatesByTime","c","time","Date","timestamp","h","getHours","timeName","measure","coord1","coord2","lat1","lat","lon1","lng","lat2","lon2","R","dLat","Math","PI","dLon","sin","cos","atan2","sqrt","d","coordinateIsIn","coordinate","coordinateGroups","index","polygon","includes","groupCoordinatesByDistance","allowedDistance","iPolygonIndex","j","distance","location","jPolygonIndex","newArr","splice","getCoordinatesInXY","coordinatesXY","getXYCoordinatesInLatLng","coordinatesLatLng","calculatePolygon","polygonXY","polygonLatLng","calculatePolygonsFromCoordinateGroups","polygons","group","getPolygon","newCoordinates","JSON","stringify","groups","loadGoogleMapsApi","cords_full","one_coordinates","dataset_1","searchRadiusButton","document","getElementById","map","googleMaps","heatmap","radius","covertToGoogleMapsCords","data","cord","window","google","maps","LatLng","weight","initMap","_initMap","addEventListener","mapElement","libraries","then","Map","center","zoom","zoomControl","scaleControl","scrollwheel","disableDoubleClickZoom","mapTypeId","createPolygonLayer","copyOfDataSet","colorizedDataset","divideColorToCordordinates","createCircelsLayer","createHeatmapLayer","calculateWeight","writePositionsToJSONByClick","creatPolygon","sColor","sOpacity","fColor","fOpacity","polygonLayer","Polygon","paths","strokeColor","strokeOpacity","strokeWeight","fillColor","fillOpacity","draggable","allCords","cordsArray","setMap","coord","Circle","color","visualization","HeatmapLayer","set","get","gradient","dividedArray","splitToChunks","sortByTimestamp","element","parts","result","ceil","stdCoordinates","crds","diff","percent","parseFloat","toFixed","changeRadius","inputValue","querySelector","value","event","arr","latLng","now"],"mappings":"AiBAA,AbAA,AYAA,AbAA,AUAA,AEAA,ATAA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,IQAMoG,UAAU,GAAGxC,OAAO,CAAC,eAAD,CAA1B;AhBAA,ADAA,AgBCA,AdAA,ACAA,AUAA,AEAA,ATAA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA;ARAA,ADAA,AiBAA,ADCA,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,ITDI5D,AiBAEsH,OjBAK,GAAGrH,AiBAE,GAAG2D,GjBAC,CAAC1D,GiBAK,CAAC,GjBAb,GAAiB,EAA/B,EAEA,EiBF0B,CAA1B;AhBCA,ADEA,AgBDA,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA;ARAA,ADEA,AiBDA,ADAA,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,SQASqH,gBAAT,CAA0BC,WAA1B,EAAuC;AhBAvC,ADEA,AiBDI,ADAJ,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,MQAQC,iBAAiB,GAAG,EAAxB;AhBAJ,AgBCID,ADAJ,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,EQAIA,WAAW,CAAC3C,OAAZ,CAAoB,UAAA6C,CAAC,EAAI;AhBA7B,ADEA,AiBDQ,ADAR,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,ITCIvH,IiBDQwH,IAAI,GAAG,IAAIC,CjBCvB,GiBDmB,CAASF,CAAC,CAACG,SAAX,CAAX;AhBAR,ADEA,AiBDQ,ADAR,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,ITCIzH,IiBDQ0H,CAAC,GAAGH,IAAI,CAACI,KjBCrB,GiBDgB,EAAR;AhBAR,AgBCQ,ADAR,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,QQAYC,QAAQ,GAAGF,CAAC,CAACnD,QAAF,KAAe,MAAf,GAAwBmD,CAAC,CAACnD,QAAF,EAAxB,GAAuC,KAAtD;AhBAR,ADEA,AgBDA,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,STCStE,gBAAT,GAA4B;ACD5B,ADEI,AiBFI,ADCR,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,QTCU,AiBFE,CAACoH,GjBECnH,KAAJ,CAAU,QiBFU,CAAC0H,QAAD,CAAtB,EAAkC,ajBEhC,CAAN;ACDJ,ADEC,AkBbDpE,ADWY6D,ADCZ,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,MQDYA,CCXL,CAAC,QAAD,CAAP,CAAkB/B,KDWW,CCX7B,ADW8BsC,QAAD,CAAjB,GAA8B,EAA9B;AhBCZ,AgBAS,ADCT,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA;ARAA,ADCA,AkBbA,AFaA,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,ISbMkD,KlBaG3K,YkBbc,GAAGqD,IlBa1B,GAAgC,AkBbC,CAAC,sBAAD,CAAjC;AjBaA,ADCI,AiBFI6D,ADER,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,IQFQA,IjBEE,IAAInH,KAAJ,CAAU,GiBFK,CAAC0H,QAAD,CAAjB,CAA4BhG,IAA5B,CAAiC0F,CAAjC,ejBEE,CAAN;ACAJ,ADCC,AkBdD,ADYK,ADEL,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,AEAA,GQVI,CCJA/D,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAhB;AjBcA,AgBDI,ADEJ,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,SUFW6D,iBAAP;AhBEJ,ADAC,AkBdD,ADaC,ADED,AbAA,AUAA,AEAA,AVFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWfIkD,QAAQ,ClBcC,EkBdE/G,OAAO,CAAC,qBAAD,CAAtB;AjBeA,ADAI,AgBCJ,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,MPDQ;ACCR,ADAQ,AkBdR,ADaA,AbGA,AYDA,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWfIuH,IlBcQ,CiBDHlD,KCbK,ClBcKzH,CiBDnB,CAAiB0H,MAAjB,EjBCY,AiBDaC,KjBCS,CiBDlC,EAAiC,OjBCzB,EAAsC,y8rEkBd9C;AjBeA,ADAYhI,AkBdZ,ADYoC,ADGpC,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWfIiL,ElBcQjL,akBdO,GlBcS,GAAGK,UAAnB,wJkBdZ;AjBeA,ADAS,AkBdT,ADYI,AbKJ,AYFA,AdCA,ACDA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWfI6K,AdiBAjF,AFDEzC,CFJE,CiBAAyE,AfIA,GAAGxE,CeJC,CjBEG,EkBdF,ADYEsE,CbKD,EcjBE6C,AhBgBE,CECD,AFDE,EeJE,CCZD,ADYE1C,CCZDhE,AdiBA,AFDH,CAAlB,CeJI,GCZY,CAAW8G,MdiBM,IcjBjB,CAAhB;AjBeA,ADAYhL,AkBbZ,ADWI,AbMA,AYHJ,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWdImL,ElBaQnL,AiBFJmI,IAAI,GAAGJ,MAAM,CAACK,EjBEM,AkBbN,CDWlB,EjBE2BlI,AkBbNkL,QAAQ,CAACC,OlBatB,OkBba,CAAwB,cAAxB,CAAzB;AjBcA,ADAS,AkBbT,ADWI,AbMA,AYHJ,AdAA,ACAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWdIC,AhBcE5H,EeHE2E,CCXR,ChBcU,CgBdDkD,CDWG,CfGC9H,EeHEuE,KfGK,CgBdpB,ADWqB,AfGA,CeHCE,CCXDsD,EDWjB,EfGgB,CAApB,EgBdA;AjBcA,ADAK,AkBbL,ADWI,AbMA,AYHJ,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,GPPI,CAME,AkBbFC,EDWInD,ICXE,ADWE,CjBEChI,CAAP,CkBbO,ADWE0H,CjBEC,CkBbhB,IDWqB,CAACI,GAAlB;AhBGJ,ADAQpI,AiBDJ,AbKA,AYHJ,AdAA,ACAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IPDQA,EiBDAuI,CAAC,AbKArC,EFHAvC,CeFG,EfEZ,CAAcC,EEGV,GaLA,AbKgB,CaXa,CjBOT,AiBDF,GjBCK1D,KIIGiG,MAAV,EAAkB,GJJ9B;ACCR,ADAK,AkBXL,AdeQ,AYHR,AdDsB,ACCtB,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,IWZMuF,IdeMtF,SAAS,GAAGD,MAAM,CcfD,AdeEE,GcfC,EdeR,EAAhB,KcfFqF,uBAA0B,CAACC,IAAD,EAAU;AjBY1C,AiBXE,ADSE,AbMIvF,AYHR,AdFA,ACEA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,ELFqC,EEK7BA,EaNAoC,GCTCmD,CDSG,GCTC,ADSEtD,AbME,CcfHiD,AdeIhF,GcfT,ADSU,CCTD,AdeV,CAAe,CaNDmC,IAAI,AbMElC,CaNDmC,EAAZ,CCTIkD,EDSa,ECTd,CDSH,CCTa,EDSU3D,IAAI,AbMlC,GaNqCQ,IAAI,CAACC,EAAZ,GAAiB,GAAnD;AhBGJ,ADDI,AkBVA,ADSA,AbMI,AYHR,AdFE7E,ACEF,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,ELFEA,IFAM,AiBDA8E,GfCC,CeDG,AfCFhF,CgBVC,AdeI,EaNA2E,AfCb,GEKkB9B,CaND,GAAGiC,IAAI,CAACC,EAAZ,GAAiB,GAAjB,AbMA,CAAuBtC,EaNA+B,IAAI,AfCTvE,GeDY6E,AbM9B,CAAP,GaNyC,AfC/C,CeDgDC,EAAZ,GAAiB,GAAnD;AhBGJ,ADDQ,AkBVFkB,ADSF,AbMC,AYHL,AdFC,ACED,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,GHDI,CAL6B,CAY7B,CclBEA,ADSE3C,CAAC,CjBCG,EiBDAwB,ICTE,ADSE,CjBCGlI,AiBDFqI,CCTD,EDSJ,CAASJ,CCTDqD,GDSK,GCTC,ADSE,CjBChB,AkBVeC,ADSf,IAAqBrD,CjBCG,CkBVhB,CAAcsD,CDSG,CAACnD,ECTlB,CAAmBoD,ADSN,CAASxD,EjBClC,EAAwC,AiBDF,CCT9B,CAA8B,CDSG,CAAhB,CAArB,GACJC,IAAI,CAACI,GAAL,CAASZ,IAAI,GAAGQ,IAAI,CAACC,EAAZ,GAAiB,GAA1B,IAAiCD,IAAI,CAACI,GAAL,CAASR,IAAI,GAAGI,IAAI,CAACC,EAAZ,GAAiB,GAA1B,CAAjC,GACAD,IAAI,CAACG,GAAL,CAASD,IAAI,GAAG,CAAhB,CADA,GACqBF,IAAI,CAACG,GAAL,CAASD,IAAI,GAAG,CAAhB,CAFzB;AhBGJ,ADDY1I,AkBVJiI,ADWJ,ADCJ,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,MPFYjI,AiBCJsH,CAAC,CCXDW,EDWI,CCXD,EAAE0D,CDWGnD,GCXC,CAACmB,ADWE,CAACd,KjBDS,AiBCd,CAAWL,CCXd,ClBUoBlI,AkBVN2H,EDWI,CCZe,ADYda,IAAL,CAAU9B,CAAV,CAAX,EjBDJ,AiBC6BwB,IAAI,CAACM,IAAL,CAAU,IAAI9B,CAAd,CAAzB,CAAZ;AhBCJ,ADDS,AkBVDmB,ADWJ,ADCJ,AdFA,ACEA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,APAA,ILFMtE,CFFE,CiBGAkF,CAAC,CCXDZ,EDWIG,CjBDG,AkBVJ,ADWE,AfDA,EgBVAqD,CDWGrE,AfDA,CeCZ,ECXa,CAACqC,AhBUlB,QgBVa,CAAcxB;AjBY3B,ADDYnI,AkBbkC,ADc1C,AbKA,AYJJ,AdFA,ACEA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,IZFM8D,EFAM9D,CkBbI,AdmBPuG,CcpBE,CDeAwC,CAAC,GAAG,IAAX,CAd6B,Afab,CeCC,EfDE,GFAO,AIM1B,GJN6B5I,AIMJ,UAAU+F,MAAV,EAAkB,CJNnC,MEAZ;ADEA,ADDS,AkBVH8F,ADWL,AbKO,AYJR,AdFA,ACEA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,IZFMjI,EgBVAiI,EdgBM9F,IchBA,EAAEyF,AdgBI,CAAC1K,AFNF,GgBVC,AhBUE,CgBVD+K,EdgBP,GFNZ,CEM6B,CAArB,EACI,OAAO9F,MAAM,CAACE,KAAP,EAAP,CAFmC,CAIvC;AHPR,ADDK,AkBhBM,AdyBH,AYPR,AdFA,ACEA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,GdRI,CAME,AEAApC,CgBhBF,MlBgBS3D,CAAP,EAAU,IEAI,GAAG,YAAvB,EAEA;ADAA,ADDQL,AkBVL,ADaH,AbMQ,AYPR,AbAA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,GIpBS,ClBkBDA,AkBlBN,KDqBOgJ,ajBHiB,CiBG1B,CAAwBC,CjBHK9I,SiBG7B,EAAoC+I,QjBH5B,QiBGR,EAAsD;AhBDtD,ADDK,AkBVJ,ADaG,ADDJ,AdDA,ACCA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,CItBA,KDuBQC,GfFClF,EeEI,GAAG,AfFhB,CeEiB,AfFDC,CeEZ;AhBDJ,ADDC,AkBTD,ADYIgF,AbMI,AYPR,AdFoB,ACEpB,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,CdrBC,CiBsBGA,EjBtBJ,II4BY1C,SAAS,CaND,CAAC/B,CbMG,EAAhB,IaNJ,CAAyB,UAAC2E,OAAD,EAAUzH,CAAV,EAAgB;AhBD7C,AgBEQ,ADDR,AdHA,ACGA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,EZH4CwC,MeIhCiF,OAAO,CAACC,QAAR,CAAiBJ,UAAjB,CAAJ,EAAkC;AhBD1C,ADFA,AiBIYE,AbKJ,AYNR,AdJoD,ACIpD,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,MGCYA,GjBJH5I,AISI,EaLI,EbKAoB,CaLGA,AbKF,CaLN,EbKS,CAAb,CJTR,CAAoBnB,AISImB,CAAC,EJTzB,CIS4BuE,CJTH,KISS,CAACjF,MAA3B,EAAmCU,CAAC,EAApC,EAAwC;AHNhD,ADFI,AiBIQ,AbKA,AYNZ,AdLA,ACKA,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,MdHQ5B,IISQ0G,CAAC,GAAGP,MAAM,CAACvE,CJTH,AISE,CAAd,IJTiBvB,UAAzB,EAAqC;ACGzC,ADFQ,AiBIC,ADDT,AdNgF,ACMhF,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA;AbAA,ADFQ,AiBIH,AbIO,AYLZ,AdPyG,ACOzG,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,GGJI,QjBCWA,EIQIoG,QJRM,CAAChG,AIQE,CAACS,EJRJ,EAAM,CAAN,CAAjB,AIQW,IAAoB,CAA3B,EAA8B;AHL1C,ADFK,AkBTL,ADaI,AbIY,AYLhB,AdPE,ACOF,AUAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,GdPyB,CAKrB,AkBVEgL,EhBKE7H,GeQG+E,ECbE,AhBKA,CEYOzC,CAAC,CcjBL,ADaZ,AfRYrC,EEYQmC,KFZD,CAACrC,CgBLC+H,EdiBQ,CAAC1F,GFZH,EgBLf,EhBKmBrC,CgBLC,CdiBO,CAAClD,IFZF,CAACmD,CEYT,GAAmB,CAApB,AFZV,CEYP,AFZd;ADOF,AiBXE+G,ADaD,AbIe,AYLhB,AdPE,AWOF,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,EIZEA,IhBKM7G,GAAG,CgBLD,CAAC6H,CdiBSxF,AFZN,CEYO,CFZnB,CAFuG,CEcjFH,AFVtB,SEU+B,CAACA,CcjBhC,CAA0B,OdiBe,CAACvF,MAAV,GAAmB,CcjBnD,AdiB+B,CAAjB,CcjBgC,YAAM;AjBYtD,AiBXI,AdiBY,AYLhB,AHAA,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,QIZQmL,IdiBY,CAAC1F,CAAC,CAACE,CAAF,EcjBH,CdiBSD,CAAC,CcjBPwE,AdiBQvE,CAAT,KAAeH,CAAC,CcjBP,AdiBQI,CcjBPuE,AdiBK,GAAMzE,CAAC,CAACE,CAAvB,KAA6B,CAACH,CAAC,CcjB9B,AdiB+BG,CcjBP,AdiBK,GAAMF,CAAC,CcjBpC,AdiBqCE,CcjBtD,AdiB6C,KAAeJ,CAAC,CAACG,CAAF,GAAMD,CAAC,CAACC,CAAvB,CAAjC,EACIJ,SAAS,CAACM,GAAV,GADJ,KAGI;AHRpB,ADHI,AkBPAgE,ADYJ,AbOa,AYRb,AdNE5G,AWMF,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,EZNEA,EgBLE4G,ChBKC,CFEG,AEFFvG,CFEGxE,EiBKAuJ,KfPP,GAAe9E,IgBLI,CAAC,AhBKpB,CFEuB,AEFFR,KFEO/D,OiBK9B,CAAoCmH,CfPlC,EAAqC3C,KFE9B,EEFP,CeOF,AfP+C,CFEG,CAAC1E,AiBKFwJ,QfPQ7E,IAAV,EAAgBC,CeO/D,CjBLQ,CiBK0D,AfPnB,EAAqB,EFEIvE,UAApE,EAAgF;ACIpF,ADHQL,AkBPF+E,ADYF,ADDJ,AdNI,AWMJ,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,IdJQ/E,EkBPF+E,ADYEoE,GCZC,WlBOe,EiBKA,CjBLG9I,EiBKA,EAAvB,MjBLI,mBkBRc;AjBYtB,ADHQ,AkBPFiM,AdkBM7F,AYPZ,AdNI,AWMJ,ARFA,ACEA,AMAA,AFAA,ACAA,AHAA,AMAA,MIXM6F,AdkBM7F,EFbF5B,GFEKxE,IkBPA,AdkBM,CAACwB,CclBL,CAAC,ChBKG,CEaT,CJXa,AIWE6E,CJXDjG,AIWd,AFbYkE,GFEC,CEFG,CFEG,AEFFG,CFEJ,CAAjB,GEFgB,CgBLP,AhBKkBf,cAAX,CAApB,CAFgE,CAGhE;ADKJ,ADHK,AkBViB,ADclB,AbOK,AYPT,AHAA,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,KIdqB,CAAjB,CAGGwI,ADWE,ICdL,ADcS3K,CCXD,ADWE,GAAG,CAAb,EAAgBA,CAAC,GCXRkK,ADWWzE,MCXZ,EAAY,GDWW,CAACnG,MAAhC,EAAwCU,CAAC,EAAzC,EAA6C;AhBAjD,AiBVM2J,ADWE,ADAR,AdNI,AWMJ,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,MIXMA,EDWMhE,AfNJ1C,CeMK,GAAGwC,ICXA,GAAGyE,AhBKA,IeMX,AfNe,EgBLjB,EhBKF,EAAyB;ADM7B,ADJI,AkBLER,ADUE,AbMA7E,AYNR,AdNM,AWMN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,IVMQA,EJXA,AkBLF6E,EDUM7B,CCVH,ChBIG1E,EgBJA,CdgBK,AFZF,CEYGgC,EchBFwE,AhBIE1G,CEYV,IaNiB,GAAGoE,ECVF,CAACuD,AhBIE,CAAC,CAAD,CgBJjB,AhBIN,CgBJyBH,AhBGF,CAEvB,MeKoC,CAAC9E,CAAC,CCVhC,ADUiC3F,CAAD,CCVD,ADUD,EAAOuH,gBAAP,CAAlC;AhBAR,ADJQ,AkBLAsD,AdiBA,AYPR,AHAA,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIVQA,AdiBIzF,McjBE,EAAE,CdiBK,GAAG,EAAhB;AHPR,ADJQ,AkBLEkB,ADSF,ADCR,AdNM,AWMN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QGDYuB,ECTFvB,AhBIAlD,CFCKhF,EkBLF,AhBIA,EgBJE,ChBIE6E,KeKQ,GAAG,CAApB,EjBJuB,AiBIA,AfLH,CFCIpE,AEDH,CAAD,CAAX,CFCc,EAAM,AkBNrB,ClBMe,AEDI,CFC3B,CEDF;ADMN,ADJK,AkBLK2H,ADSEe,AbOJ,AYNR,AdNM,AWMN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,GdRI,CAGE,EiBIMA,GbOC,CchBHf,AhBIEnD,CFCA3E,CAAN,CkBLO,AdgBIsB,AFZF,CFCD,AIWI,CchBH,ChBIGoD,CEYGmB,EFZA,CAACjF,EeKM,CAACW,AbOF,CAACX,EFZV,CeKN,CAAsB,CAACqG,AfLJ,CeKK,AbOf,AFZf,CeK+B3F,CAAD,CAAF,AbOG,CaPzB,AbOJ,EAAgCA,CAAC,IAAI,CAArC,EAAwCA,CAAC,EAAzC,EAA6C;AHNrD,ADJQ,AkBRQ,ADYJ6H,AbOA,AYNZ,AdNM,AWMN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,MGDYA,EjBJA,CkBT+B,CdoB3B/C,AFZJxB,CEYK,GAAGiB,KaPK,CbOC,CAACvE,CaPCuH,AbOF,CAAd,CFZc,GAAGnE,GAAG,CAAC,CAAD,CAAH,KeKe,AfLJ,CeKK9D,EfLhB,IeKD,AfLmB8D,GeKO,AfLJ,CeKtC,AfLuCC,GAAD,CAAH,KAAa,GAAtD;ADMN,ADJY,AkBLJyH,ADSC,ADCT,AdNM,AWMN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIVQA,EhBIIvH,EgBJA,EAAE,EAL6B,QhBSjB,GAAGH,GAAG,CAAC,CAAD,CAAH,KAAW,GAAX,IAAkBA,GAAG,CAACC,GAAD,CAAH,KAAa,GAAtD,CANuB,CAQvB;ADIN,ADJY,AkBLJ0H,AdeI,AYLZ,AHAA,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIVQA,KlBKW3M,AIUAgH,McfA,EAAE,CdeO,CAAC9F,GcrBc,GlBWR,AIUhB,CJViBR,GIUG,CJVpB,AIUP,CJV6B,CIUC,GJVvB,EAA4BD,GAA5B,EAAiC,CAAjC,CAAP;ACKZ,ADJS,AkBLDmM,ADQA,AbOQ,AYLhB,AdLM,AWKN,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,KdRQ,CAGE,EkBLFA,CDQK,CfHHzH,EEUUwB,CJVJrG,AiBGCoJ,AbOI,CJVX,AiBGQ,EjBHA,AIUM1C,CaPH,CAAb,ECRY,ADQI0C,CAAC,CCRH,EDQMrC,AfHJ,CEUS,CAACL,CctBS,ChBYf9B,OeGW,AbOI,CaPHhE,AbOIA,MaPpC,AbO0B,AFV5B,EeG0CwI,AfHJ,CeGK,AbOI,CAApB,CaPzB,AbOQ,EaPqC;AhBErD,ADJY,AkBLJmD,ADQI,AbOI,AYLhB,AdLQ7H,AWKR,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIVQ6H,AhBKA7H,EeGQ,CfHL,CeGOpD,AbOEgF,CaPD,AbOE,CFVP5B,EEUUgC,CFVP,CeGO0C,AfHNtE,CgBLC,ADQH,CAAJ,CCRS,CDQO,GbOK,CcvBU,AduBT4B,CFVpB,CAAc,CAAd,EAAiB/B,GAAjB,CEU6B,AFVnC,CEUoC/D,AFXA,CAGpC,KEQ0B,GAAmB,CAApB,CAAjB;AHLhB,ADJY,AkBLJ4L,ADQQ,AbOA,AYLhB,AHAA,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIVQA,IDQYnD,AbOA,CJVD3J,AIUE2G,CAAC,CAACE,CAAF,GAAMD,CaPC,AbOA,CAACC,CAAT,CaPWiB,IbOIpB,CAAC,CJVD,AIUEI,CJVDpG,AkBLN,ADQQ,AbOH,CaPI6G,CCRP,ADQQ,CAAC3F,AbOAgF,CJVtB,AiBGqB,AbOE,CJVD,AiBGF,AbOIE,CcxBA,ADiBC8C,AbOxB,GJVD,EAA4BnJ,AIUE,CAACkG,CAAC,CJVhC,AiBGmB,AbOcG,CAAF,CJVE,AiBGES,CjBHnC,AiBGoC,CjBH3C,AiBG4CmC,AbOA9C,CaPD,AbOE,CaPH,AbOIE,CaPC8C,AbOV,KAAelD,CAAC,CAACG,CaP5B,AbO0B,CaPhD,EbOsDD,CAAC,CAACC,CAAvB,CAAjC,EACIG,SAAS,CAACD,GAAV,GADJ,KAGI;AHRpB,ADJS,AkBLDgG,AdkBK,AYRb,AdJQ,AWIR,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,QIVQA,IhBMI7H,KgBNK,EAAE,OhBMX,EAAoB;ADI5B,ADJK,AkBhBsC,ADkB3B,ADGhB,AdJUF,AWIV,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,OIrBY,CAAN,CAHkB,CAgBlB,AhBIIA,EeCU2E,CfDP,GAAG3E,GAAG,CeCS,AfDRK,IeCYmE,GfDhB,CAAYxF,WeCZ,AfDA,EeCiC,AfDRF,OAAzB,CAAN;ADIV,ADFC,AiBAmB,AbURkD,AYPZ,AdJS,AWIT,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,MVOYA,QaVY6C,CbUH,CAAChI,IAAV,CAAe6E,CAAf,KaVyB,GAAGuC,cAAc,CAAC1B,CAAC,CAACmC,CAAD,CAAF,EAAOP,gBAAP,CAAlC;AhBGpB,AiBRM6D,AdgBG,AYPT,AdJO,AWIP,ARFA,ACEA,AMAA,ADAA,AHAA,AMAA,MITMA,ChBFA,MAOO,WgBLW,CAAC9B,SAAD,CAAlB,CAjBkB,CAmBlB;AjBON,ADHA,AiBAoB,ADIpB,AdJQ,AWIR,APAA,AMAA,ADAA,AHAA,AMAA,SdJSvK,KiBAekJ,UjBAxB,CAAyBjJ,EiBAY,GAAG,CjBAxC,AiBAoB,EjBAa,AiBAU;AhBI3C,ADHI,AkBJE,ADIkBuI,AbUhBnC,AYNR,AdJQhC,AWIR,APAA,AMAA,ADAA,AHAA,AMAA,IVMQgC,EJVA/G,EEAA+E,EgBJEiI,ChBIC,CeAa9D,CbUP,CAACpC,AFVJ/B,GEUN,AFVS,CAACM,IAAJ,CgBJS,ClBIG,AEAlB,IeAgC,CjBAT/E,AiBAUkJ,YjBArC,CiBAoC,CjBAK,AiBArB,CAAgC5H,CCJ1BqJ,GDIN,CAAqC3D,CAAC,CAACmC,CAAD,CAAtC,CCJD,CAAjB;AjBQN,ADHQ,AiBAa,AbWb,AYPR,AdJO,AWIP,APAA,AMAA,ADAA,AHAA,AMAA,QVOYjD,GabQ,MAEO,AbWN,CAACvF,GaXS2I,GbWnB,IAAoB,CAApB,IAAyB7C,CaXO,KAAKyC,GbWH,CAACvI,MAAV,GaXV,CbW8B,CaXO,AbWpD,IAAkDuF,SAAS,CAAC,CAAD,CAAT,CAAaI,CAAb,IAAkBG,SAAS,CAAC,CAAD,CAAT,CAAaH,CAAjF,IAAsFJ,SAAS,CAAC,CAAD,CAAT,CAAaK,CAAb,IAAkBE,SAAS,CAAC,CAAD,CAAT,CAAaF,CAAzH,EACI,OAAOL,SAAP,CADJ,KAGI,OAAOA,SAAS,CAACtF,MAAV,CAAiB6F,SAAjB,CAAP;AHVZ,ADHQ,AkBLF,ADKkB,AbcnB,AYVL,AHAA,APAA,AMAA,ADAA,AHAA,AMAA,GVhCI,OcuBMkG,ClBKK3M,KiBAauJ,MAAM,CjBAP,CAAClJ,CiBASuI,CCLX,GAAGgE,ClBKF,CAAnB,UiBA6C,CAAC1D,aCLC,ADKF,CCLGwD,ADKnB,CAAgC9L,MAAhC,CAAuCgI,KCLrB,CAAjD,UDKsF,CAACU,aAAD,CAAvD,CAAb;AhBIxB,ADHK,AkBLCuD,ADKkBjE,ADIxB,AdJM5E,AWIN,APAA,AMAA,ADAA,AHAA,AMAA,GdRiC,CAK7B,EkBNE6I,AhBKA7I,GAAG,CAACQ,EeAcoE,CfAf,CAAH,GAAWnE,GAAX,IgBLkB,CAACkI,GDKe,CAACnD,MAAjB,CAAwBN,KCLxB,CAAlB,CAtBkB,CAwBlB,KDGkB,EAAuC,CAAvC;AhBIxB,AgBHwBN,AbepB,AYXJ,AdJK,AWIL,APAA,AMAA,ADAA,AHAA,AMAA,KZ1BI,EEqCK5C,IFfE,CeAa4C,GfAT9E,KAAJ,EAAW,CEelB,GAAwB,EafY,CAAC0F,MAAjB,CAAwBF,AbeV5C,CAAV,EAAaC,CAAb,EAAgB,OafpB,EAAuC,CAAvC;AhBIxB,AiBPMmG,ADIkBlE,AbehB,AYXR,AdJMxF,AWIN,APAA,AMAA,ADAA,AHAA,AMAA,MIRM0J,AhBIA1J,EEeMsD,CAAC,AFfJ,CEeKJ,CAAF,CafYsC,EbeNjC,CAAC,CAACL,CAAZ,EACI,KcpBY,CAAC6E,CdoBN,CAAC,CahBoB,AbgB5B,CahB6B7J,AbejC,IafgB,CAAsBiI,AbiBjC,IAAI7C,CAAC,CajBM,AbiBLJ,CAAF,GAAMK,CAAC,CAACL,CAAZ,CcrBmC,CAACyG,AdsBrC,OAAO,CAAC,CAAR,CADC,KcrBmD,AduBnD,CcvBoDpC,ChBINtG,EEmB1CqC,CAAC,AFnB4C,CEmB3CH,CAAF,CFnBgD,CAAxD,CgBJuD,AduBzCI,CcvByB,AduBxB,CcvBA,AduBCJ,CcvBnB,AduBO,EACD,OAAO,CAAC,CAAR,AFpB2DnC,CEmB1D,GFnBJ,EEqBI,AFrBP,IEqBWsC,CAAC,CAACH,CAAF,GAAMI,CAAC,CAACJ,CAAZ,EACD,OAAO,CAAC,CAAR,CADC,KAGD,OAAO,CAAP;AHpBZ,ADJI,AkBHEyG,ADIkB9D,AbwBnB,AYpBL,AdJK,AWIL,APAA,AMAA,ADAA,AHAA,AMAA,GVSI,GJdI,AkBHF8D,ClBGGtN,KiBCewJ,ajBDG,AiBCU,GAAGN,EjBDR/I,GkBHC,WDIuB,CAACc,IjBDhD,EiBC+B,EjBDe,CAACjB,AiBCU,CAA1C,iBjBDhB,KAAuEM,YAA3E,EAAyF;ACK7F,ADJQN,AkBHH,ADImB4J,AbyBvB,AYrBD,AdJG,AWIH,APAA,AMAA,ADAA,AHAA,AMAA,CVlDiB,EAAjB,AFiBE,CF4BM5J,CkBjCJ,ODkCoB4J,UjBDE,GAAGtJ,AiBCQ,GAAGkJ,SjBDhC,IiBCgB;AhBIxB,ADJQ,AkBHL,ADIkB,AbyBrB3J,AYrBA,AdHE,AWGF,APAA,AMAA,ADAA,AHAA,AMAA,GI1CE,Gd+DI,CAACC,EFxBEwE,EFFMhE,CEEb,EEwBF,GAAiB0F,MJ1BU,CAACrF,GI0B5B,GJ1B2B,CAAnB;ACKR,ADJK,AkBHJ,ADIgB,ADIjB,AdHC,AWGD,APAA,AMAA,ADAA,AHAA,AMAA,CI5CA,ChB2CA;ADCA,AiBLA,ADEa,ADIb,AHAA,APAA,AMAA,ADAA,AHAA,AMAA;AbAA,ADLI,AiBEK,ADIT,AHAA,APAA,AMAA,ADAA,AHAA,AMAA,MdNQ;ACMR,ADLQ,AiBEH,ADIL,AdHA,AWGA,APAA,AMAA,ADAA,AHAA,AMAA,SZHS2E,MAAT,CAAiBnB;ADGjB,ADLQ,AgBMR,AdJyB,AWIzB,APAA,AMAA,ADAA,AHAA,AMAA,WdNenE,kBAAkB,CAACW,MAAD,CAAzB;ACMR,ADLK,AiBCD,ADKJ,AdLA,AIKA,AMAA,ADAA,AHAA,AMAA,GdTI,CAGE,KiBCKuI,EjBDE7I,CAAP,EAAS,WiBCX;AhBKJ,ADLQ,AkBDR,ADEC,ADKD,AdNsD,AIMtD,AMAA,ADAA,AHAA,AMAA,IIPMkN,IlBCM,QkBDM,GAAG,SAAfA,YAAe,CAACnG,WAAD,EAAcoG,MAAd,EAAsBC,QAAtB,EAAgCzB,MAAhC,EAAwC0B,MAAxC,EAAgDC,QAAhD,EAA6D;AjBOlF,ADLY,AkBDV,AFOF,AdPgF,AIOhF,AMAA,ADAA,AHAA,AMAA,MIPMC,YAAY,GAAG,IAAI/B,MAAM,CAACC,IAAP,CAAY+B,OAAhB,CAAwB;AjBO7C,ADLY,AkBDRC,ADEJ,ADKA,AdPE,AIOF,AMAA,ADAA,AHAA,AMAA,IIPIA,EhBAEvI,GgBAG,ADEAwE,ECFE3C,ElBCQpH,GEDH,GAAGyD,GgBD0B,ChBCtB,CAAC+B,GeExB,CAA4B4B,GjBDS,AEDlB,CFCmB3G,AEDNb,IFCb,CAAwB,EiBC3C,AfFuC,CAACuD,CFCrB,AiBCsB,EjBDQxC,AEDjB,EAAb,EAA4B,EFC5B,CAAP,GEDO,CAAjB;ADOF,ADLS,AkBDLoN,ADEA,ADKJ,AdPE,AIOF,AMAA,ADAA,AHAA,AMAA,IIPIA,ClBFI,CAGE,AiBCF/D,AfFFvE,OFCWpF,CAAP,CkBDK,ClBCI,CkBDFmN,EDEI,GAAG,CCJqB,CDIzC;AhBKJ,ADLY,AkBDRQ,ADEA5G,ADKJ,AdRe,AIQf,AMAA,ADAA,AHAA,AMAA,EGLIA,ECFA4G,SDEW,CAACvJ,GCFC,EAAEgJ,EDEf,CAAoB,KCLqB,KDKrBnG,CAAC,EAAI;AhBK7B,ADLY,AkBDR2G,ADEIjE,ADKR,AdTc,AISd,AMAA,ADAA,AHAA,AMAA,IIPIiE,ADEIjE,AfJuB,MAA7B,MgBEc,CDEK,CCFHgC,ADEIpK,IAAd,CAAmB,CCNkB;AjBW7C,ADLY,AkBDRsM,ADEQtH,ADKZ,AdTE,AISF,AMAA,ADAA,AHAA,AMAA,IIPIsH,EDEQtH,AfJNxC,CeIO,EAAEkD,CAAC,CAACqC,AfJN,EFGQ3J,AkBDN,ChBFC,CgBEC0N,IDEA,AfJb,CeIwBzF,CCPmB,EDMlB,QjBAU,CAACxH,IAAnB,CAAwB,IAAxB,EAA8BE,MAA9B,CAAP;ACMZ,ADLS,AkBDLwN,ADEQtH,ADKZ,AVAA,AMAA,ADAA,AHAA,IUPIsH,EDEQtH,CAAC,EAAES,CAAC,CAACqC,ICFF,EAAEgE,EDEF,CAAWxF,KCRmB;AjBa7C,ADLK,AkBDDiG,ADDuB,ADQ3B,AdTE,AISF,AMAA,ADAA,AHAA,IUPIA,CDDI,CfDFjK,OgBEO,AhBFX,EgBEa,AhBFA;ADSf,ADFC,AkBZ4C,ADUxC,ADKL,AdTI,AISJ,AMAA,ADAA,AHAA,GUfqB,ADKjB,CCLF,IhBMMA,OAAO,CAACV,IAAR,IAAgB,IAApB,EAA0B;ADS9B,AiBJE,ADAE,ADKJ,AdTM8B,AISN,AMAA,ADAA,AHAA,MNTMA,GgBIGqI,ADAE5D,OfJK,GAAG7F,EgBIjB,CDAE,IfJsB,CAACV,IAArB;ADSN,ADHA,AkBDC,ADAA,ADKD,AdTK,AISL,AMAA,ADAA,AHAA,CUlBA,GlBcI7C,KAAK,GAAG,EAAZ;ACIA,ADHA,AkBAA,AFIA,AVAA,AMAA,ADAA,AHAA,IRJIC,QAAQ,GAAG,KAAf;ACIA,ADHA,AiBDA,ADKA,AdVI,AIUJ,AMAA,ADAA,AHAA,IRJIC,IENIqD,CeKC8F,MfLM,CFMf,AENgBxE,QAAR,IAAoB,IAAxB,CeKJ,CAAkC2B,AfLA,WeKlC,EAA+C;AhBK/C,ADHA,AiBDI,ADKJ,AdVM3B,AIUN,AMAA,ADAA,AHAA,IRJI1E,EiBDImJ,AfLFzE,QFMQ,AENA,GFMG,AENAtB,CFMC,CAAlB,IiBDyB,CfLD,CAACsB,CeKG,EAAxB,KfLE;ADUN,AgBJI2B,ADKJ,AdVK,AIUL,AMAA,ADAA,AHAA,ESLIA,WAAW,CAAC3C,OAAZ,CAAoB,UAAA6C,CAAC,EAAI;AhBK7B,ADHA,AiBDQ4C,ADKR,AVAA,AMAA,ADAA,AHAA,ISLQA,KjBCClJ,YiBDgB,CAACY,EjBC1B,EiBDQ,CjBCmB,AiBDI;AhBK/B,ADHI,AkBDJ,ADAYqG,ADKZ,AdXI,AIWJ,AMAA,ADAA,AHAA,IULM8E,ElBCE,AiBDI9E,CjBCHpH,CEPDsD,CeMO,EAAEmD,CAAC,CAACV,CADY,CjBEvB,AEPO,CAACxC,GFOK,CAACtD,CEPd,CgBMgB,GAAG,AhBNF,IAArB,EAA2B,CFO3B,EAAgC,AkBD9BiM,kBAAqB,CAAC3F,WAAD,EAAiB;AjBK5C,ADHQ,AkBDN,ADAUe,ADKZ,AdXM/D,AIWN,AMAA,ADAA,AHAA,MULMiK,ADAMlG,AfNN/D,GeMS,EAAEkD,AfNN,CeMO,CAACT,CCAL,AhBNA,GgBMG0D,ChBNX,OgBMmB,CAACnD,WAAD,EAAc,CAAd,CAAR,CAAyB,aAAzB,CAAf;AjBKF,ADHK,AkBDHiH,ADH6B,ADQ/B,AdXK,AIWL,AMAA,ADAA,AHAA,EULEA,GDHM,KCGE,CAAC5J,OAAT,CAAiB,UAAA6J,UAAU,EAAI;AjBKjC,AiBJI,ADAC,ADKL,AdXG,AIWH,AMAA,ADAA,AHAA,GSVI,KCKIlF,OAAO,GAAGmE,YAAY,CAACe,UAAD,EAAa,oBAAb,EAAmC,GAAnC,EAAwC,CAAxC,EAA2C,oBAA3C,EAAiE,GAAjE,CAA1B;AjBKJ,ADJIzN,AkBAAuI,ADAA,ADKJ,AVAA,AMAA,ADAA,AHAA,ERLIvI,EkBAAuI,KDAOc,CjBAC,CkBAD,CAACqE,ClBAG,KAAX,AkBAA,CAAelD,GAAf,IDAA;AhBKJ,AiBJG,ADAF,ADKD,AdXE,AIWF,AMAA,ADAA,AHAA,GURE,GhBHI;ADWN,ADLI,AkBCH,AFKD,AdXI,AIWJ,AMAA,ADAA,AHAA,CUXA,KlBKQvK,YAAY,CAACG,MAAjB,EAAyB;ACM7B,ADLQL,AiBCR,ADKA,AdXI,AIWJ,AMAA,ADAA,AHAA,IRNQA,IELE8E,CFKG,AiBCJyE,GjBDOrJ,EELA,GAAGmD,KAAK,CAACV,CFKG,CAACrC,AiBC7B,AfN2B,CeMDkG,AfNEzB,KFKZ,CAAoB/E,KAApB,AiBChB,CjBDQ,AELiB,CeMc,AfNE2E,UAAhB,EAA4B;ADWrD,ADLK,AkBCL,ADAI,ADKJ,AdZuDE,AIYvD,AMAA,ADAA,AHAA,GRRI,CkBGE0H,EDAEnD,AfP+CvE,GFM5C,KENoD,EAARA,GeOlC,GCAG,ADAAsE,GCAG,SAArBoD,MDAoC,CAAC/F,WCAhB,ADAe,CCAdA,ADAxB,CADmC,CAEnC,SCDuB,EAAiB;AjBK5C,ADLQrG,AkBCNqG,AFKF,AdbqD,AIarD,AMAA,ADAA,AHAA,EULEA,ElBDMrG,CEPiB,CAAD,EAA4C,KgBQvD,ClBDK,AkBCJ0D,GlBDO,CAAC,CAAd,EkBCN,CAAoB,UAAA2C,WAAW,EAAI;AjBKrC,ADLK,AkBCD,ADAA,ADKJ,AddsEhD,AIctE,AMAA,ADAA,AHAA,MSLQgG,AfT8DhG,GgBS7D,EhBTkE,EgBS9DoK,AhBTyDpK,EeSrD,GCAb,ADAgB8C,ICAEE,MDAQ,CAAC4C,ICA3B,EAA+B,ODAL,CAA1B;AhBKJ,AiBJM,ADAF,ADKJ,AdfoE,AIepE,AMAA,ADAA,AHAA,KNfwB,CeUhBK,AfVJ,IgBUMuB,MAAM,CAACC,EDAI,GAAG5B,CCAd,CAAc6B,IAAd,CAAmB2C,MAAvB,CAA8B,UDAY,CAACrE,SAAD,CAA5C;AhBKJ,ADNI,AkBEI2D,ADAJ,ADKJ,AddInI,AIcJ,AMAA,ADAA,AHAA,INdIA,EFOIhF,EkBEAmN,CDAG1D,CfTD,CFOG,AEPFxE,CFOG5E,GEPV,CAAYyE,EFOZ,CkBEe,ClBFG,CkBED,CDAjB,AfTA,EAAoBjB,MgBQY,ChBRhC,CAA4B,UAAUK,GAAV,EAAe;ADc/C,ADNQ3D,AkBEA6M,ADAP,ADKD,AddM,AIcN,AMAA,ADAA,AHAA,IRPQ7M,IkBEA6M,EhBTE,CAACpI,GFOO,GEPD,CAAC7D,GgBSG,EAAE,GAFa,ChBPzB,CAAiB+D,cAAjB,CAAgCrF,IAAhC,CAAqCb,OAAO,CAACsC,GAA7C,EAAkD4C,GAAlD,CAAL,EAA6D;ADcnE,ADNK,AkBEGmJ,AFKR,AddQrO,AIcR,AMAA,ADAA,AHAA,QULQqO,AhBTArO,OAAO,CAACsC,GAAR,CgBSY,AhBTA4C,EgBSE,CAHc,AhBN5B,IAAmBY,MAAM,CAACZ,GAAD,CAAzB;ADcR,ADNC,AkBEOoJ,ADAR,ADKA,AddO,AIcP,AMAA,ADAA,AHAA,ONhBM,CgBWEA,CDAC5D,IfTI,IgBSI,AhBTAlG,EgBSEgD,GhBTN,EAAW,MgBSM,CAACoH,KAAD,CAAX,CAAmBE,KAJF,GDIpC,CAA+CxF,gBAA/C,EAAiE;AhBKjE,AiBJQiF,ADAJ,ADKJ,AddQzK,AIcR,AMAA,ADAA,AHAA,MSLQ6G,ECAA4D,AhBTAzK,GAAG,GeSK,GAAG,ECAA,ADAf,ECAiB,GhBTLoB,CgBIoB,EhBJzB,wEAAH;ADcR,ADNA,AkBEQuG,ADAJnC,ADKJ,AddO,AIcP,AMAA,ADAA,AHAA,ESLIA,MCAImC,ClBFClK,EkBEE,EAAEkK,GANuB,EDMhB,CjBFpB,AiBEqB5G,GjBFC,IiBElB,CAAyB,UAAA+F,KAAK,EAAI;AhBKtC,ADNI,AkBEIgC,ADAAjC,ADKR,AddK,AIcL,AMAA,ADAA,AHAA,ISLQA,CffJ,CFaI1J,EkBEA2L,IDAQ,CAAC5K,CjBFb,AkBEU,ElBFI,AkBEFwF,CDAR,CAAc+C,SCAK,CAACqE,KAAD,CAAX,ADAsB,CCAH7E,ADAIa,KAAD,CAA9B,ECP4B;AjBYpC,ADNQ,AkBEAgB,ADAH,ADKL,AdbI,AIaJ,AMAA,ADAA,AHAA,GSPI,KCEIA,GhBRG,GgBQG,EAAE,CARoB,CAQlB;AjBKlB,ADNK,AiBED,ADKJ,Adda9F,AIcb,AMAA,ADAA,AHAA,MNdaA,GeSF6E,GfTQ,EAAN7E,GeST;AhBKJ,AiBdoC,ADUnC,ADKD,AdfW,AIeX,AMAA,ADAA,AHAA,KNfI,EgBAE;AjBeN,ADPI,AkBEC,AFML,AdfG,AIeH,AMAA,ADAA,AHAA,GN5BE,CAaE,EFOItE,KEPGf,CAAP,CFOW,CEPD,EFOIE,UAAU,CAACS,eAAD,CAAxB;ACQJ,ADPIH,AkBED,ADCH,ADKA,AdfI,AIeJ,AMAA,ADAA,AHAA,ERRIA,CkBXF,MDcO4J,CjBHG,CEPD,EFOI,IAAX,EiBGJ,CAAoBrD,WAApB,EAAiCmC,eAAjC,EAAkD;AhBKlD,ADNI,AkBCH,ADCG,ADKJ,AdhBaxD,AIgBb,AMAA,ADAA,AHAA,CUrBA,KlBcQ1E,AiBEAqJ,AfXK3E,GFSF,EETO,CFSJnF,CETMP,IFSD,CAACY,EiBEE,GAAG0J,CjBFrB,GiBEyB,CAAC1G,KAAL,CAAW0G,IAAI,CAACC,SAAL,CAAexD,WAAf,CAAX,CAArB;AhBKJ,AiBJA,ADAI,ADKJ,AdjBW,AIiBX,AMAA,ADAA,AHAA,KNjBI,CeYIyD,MAAM,GAAGvB,0BAA0B,CAACoB,cAAD,EAAiBnB,eAAjB,CAAvC;AhBKJ,ADPI,AiBGA,ADKJ,AdjBG,AIiBH,AMAA,ADAA,AHAA,MSLQgB,GjBHElJ,GAAN,EAAW,AiBGC,GAAGiJ,qCAAqC,CAACO,MAAD,CAApD;AhBKJ,ADPQ/J,AiBGJ,ADKJ,AdjBC,AIiBD,AMAA,ADAA,AHAA,IRRQA,KiBGGyJ,OjBHS,CiBGhB,EjBHmB3J,KAAf;ACQR,ADPQA,AiBGP,ADKD,AVAA,AMAA,ADAA,AHAA,IRRQA,KAAK,GAAG,EAAR;ACQR,AeCA,AdjBAf,AIiBA,AMAA,ADAA,AHAA,MNjBM,CAACC,OAAP,CAAewF,MAAf,GAAwBA,MAAxB;ADiBA,ADRQ,AkBGR,ADGA,ADGA,AdjBAzF,AIiBA,AMAA,ADAA,AHAA,IUNMuN,EhBXA,CAACtN,EecEwB,EjBNM,CiBMf,CjBNiBP,AiBMJqG,Cfdb,CAAenD,KAAf,EgBWwB,ClBHT,AERQA,CecvB,CCH2B,ClBHG5C,AiBMJkI,Efd1B,CFQQ,EAA2B,GkBG7B6D,ODGN,EAA2C,SCHhB,CAAChG,WAAD,EAAiB;AjBM5C,ADRY,AkBIVmE,ADEE,ADGJ,AVAA,AMAA,ADAA,AHAA,EULEA,IDEMlE,GCFC,ClBJOvG,EkBIJ,IAAIwK,MlBJJ,CiBMa,CjBNK,EkBIJ,ADEEnE,CCFDwH,aAAX,CAAyBC,CDEG,CAACxH,UCFjC,CAA0C,ADEV,CAAxC;AhBGJ,ADRgBtG,AkBIZ4K,ADEA,ADGJ,AVAA,AMAA,ADAA,AHAA,IULIA,EDEInB,EjBNQzJ,AkBIR,EAAEsG,IDEM,GAAG,EAAf,CjBNwB,CAACrG,UAAD,CAAZ,CAAyBO,GAAzB;ACShB,ADRa,AkBEyC,AFOtD,AVAA,AMAA,ADAA,AHAA,GUPY,CAAV;AjBOF,ADRS,AkBKPiK,ADAE,ADIJ,AVAA,AMAA,ADAA,AHAA,EUJEA,KDAO,ECAA,CAACgD,CDAGzJ,GAAT,ECAF,CAAeuG,CDAGhE,ECAlB,eDAE,EAAmC;AhBIvC,AiBFEkE,ADDMhB,ADIR,AVAA,AMAA,ADAA,AHAA,EUHEgB,EDDMhB,KCCC,CAACsE,EDDM,CCCd,ADDe/J,CCCH,EDDE,CAAR,GAAgB2F,ECCtB,EAAsBc,MDDU,CCCH,ADDIlE,CCCHyH,GAAR,CAAY,QAAZ,IAAwBtD,ADDI,CAAC1G,GAAD,CAAlB,CCCV,CDDmCyE,ECCFiC,MAAvD,ODDgC,CAA1B;AhBIR,ADTQzK,AkBQN,ADFG,ADIL,AVAA,AMAA,ADAA,AHAA,IRVQA,EkBQFgO,QlBRY,AkBQJ,GlBRO,AkBQJ,ClBRK,AkBSlB,ClBTI,mBkBQS,EAEb,oBAFa,EAGb,qBAHa,EAIb,sBAJa,EAKb,qBALa,EAMb,oBANa,CAAf;AjBEF,ADTQ1N,AkBgBNkK,AFNF,AVAA,AMAA,ADAA,AHAA,EUMEA,ElBhBMlK,GAAG,EkBgBF,ClBhBKT,AkBgBJiO,GAAR,CAAY,ClBhBK,CAAC5N,MAAZ,EkBgBN,EAAwBsK,OAAO,CAACuD,GAAR,CAAY,UAAZ,IAA0B,IAA1B,GAAiCC,QAAzD;AjBNF,ADTK,AkBiBJ,ADZG,ADKJ,AVAA,AMAA,ADAA,AHAA,CUdA,QDSWxE,QAAP;AhBKJ,AgBJC,ADKD,AVAA,AMAA,ADAA,AHAA;APAA,ADVIzJ,AkBoBJ,AFTA,AVAA,AMAA,ADAA,AHAA,ERXIA,EkBoBEoM,UlBpBU,GAAG,IAAf,SkBoB4B,GAAG,SAA7BA,0BAA6B,CAAC9F,WAAD,EAAiB;AjBTpD,ADVIvG,AkBqBF,ADfFhB,ADKA,AVAA,AMAA,ADAA,AHAA,ERXIgB,IkBqBEmO,ADfA,CAAClP,GjBNK,GAAG,CiBMf,GAAiBwB,CjBNb,AkBqBc,EDflB,CCeqB2N,aAAa,CAACC,eAAe,CAAC9H,WAAD,CAAhB,EAA+B,CAA/B,CAAhC,CAFkD,CAIlD;AjBZF,ADVI1G,AgBWJ,AVAA,AMAA,ADAA,AHAA,ERXIA,eAAe,CAACU,OAAD,CAAf;ACWJ,ADVC,AkBsBC4N,AFXF,AVAA,AMAA,ADAA,AHAA,EUWEA,YAAY,CAAC,CAAD,CAAZ,CAAgBvK,OAAhB,CAAwB,UAAA0K,OAAO,EAAI;AjBXrC,AiBYIA,AFXJ,AVAA,AMAA,ADAA,AHAA,IUWIA,OAAO,CAACT,KAAR,GAAgB,sBAAhB;AjBXJ,ADVA9O,AkBsBG,AFXH,AVAA,AMAA,ADAA,AHAA,GUSE,IlBpBK,CAAC2B,QAAR,GAAmB,UAAUf,GAAV,EAAe;ACWlC,ADVI,AkBuBFwO,AFZF,AVAA,AMAA,ADAA,AHAA,EUYEA,IlBvBMxN,IAAI,GAAG,CkBuBD,CAAC,CAAD,ClBvBKC,AkBuBjB,CAAgBgD,IlBvBH,CAAU/C,EkBuBvB,CAAwB,MlBvBQ,CAACT,GkBuBTkO,GlBvBD,GAAmB,CAA7B,AkBuBkB,ClBvB7B,CkBuBiC;AjBZrC,AiBaIA,AFZJ,AVAA,AMAA,ADAA,AHAA,IUYIA,OAAO,CAACT,KAAR,GAAgB,oBAAhB;AjBZJ,ADXI,AkBwBD,AFZH,AVAA,AMAA,ADAA,AHAA,GUUE,GlBtBMhN,SAAS,CAACT,MAAV,GAAmB,CAAvB,EAA0B;ACY9B,ADXQ,AkByBN+N,AFbF,AVAA,AMAA,ADAA,AHAA,EUaEA,OlBzBW,IAAIrN,CAAC,AkByBJ,CAAC,CAAD,ClBzBO,AkByBnB,ClBzBM,AkByBU8C,ElBzBM9C,CAAC,GAAGD,CkByB1B,CAAwB,OlBzBW,CAACT,EkByBZkO,IlBzBlB,EAAsCxN,CAAC,AkByBd,ElBzBzB,AkByB6B,ElBzBc;ACYnD,ADXYH,AkByBR2N,AFbJ,AVAA,AMAA,ADAA,AHAA,IUaIA,ElBzBQ3N,IAAI,CAACG,AkByBN,ClBzBO,AkByBN+M,GlBzBS,CAAL,CAAJ,AkByBR,GlBzBsBhN,AkByBN,SlBzBe,CAACC,CAAD,CAAvB,SkByBR;AjBbJ,ADXS,AkByBN,AFbH,AVAA,AMAA,ADAA,AHAA,GUWE;AjBXF,ADXK,AkB0BHqN,AFdF,AVAA,AMAA,ADAA,AHAA,EUcEA,YAAY,CAAC,CAAD,CAAZ,CAAgBvK,OAAhB,CAAwB,UAAA0K,OAAO,EAAI;AjBdrC,AiBeIA,AFdJ,AVAA,AMAA,ADAA,AHAA,IUcIA,OAAO,CAACT,KAAR,GAAgB,sBAAhB;AjBdJ,ADZI9N,AkB2BD,AFdH,AVAA,AMAA,ADAA,AHAA,ERbIA,CkByBF,IlBzBO,CAACgB,IAAN,CAAW,IAAIC,IAAJ,CAASrB,GAAT,EAAcgB,IAAd,CAAX;ACaJ,AiBgBEwN,AFfF,AVAA,AMAA,ADAA,AHAA,EUeEA,YAAY,CAAC,CAAD,CAAZ,CAAgBvK,OAAhB,CAAwB,UAAA0K,OAAO,EAAI;AjBfrC,ADbI,AkB6BAA,AFfJ,AVAA,AMAA,ADAA,AHAA,IUeIA,ElB7BIvO,KAAK,AkB6BF,ClB7BGK,AkB6BFyN,KAAR,ClB7BI,EkB6BY,GlB7BK,CAAjB,IAAsB,CAAC7N,QAA3B,EAAqC,EkB6BrC;AjBfJ,ADbQN,AkB6BL,AFfH,AVAA,AMAA,GMaE,ClB3BMA,UAAU,CAACY,UAAD,CAAV;ACcR,ADbK,AkB8BH6N,AFhBF,AVAA,AMAA,EMgBEA,YAAY,CAAC,CAAD,CAAZ,CAAgBvK,OAAhB,CAAwB,UAAA0K,OAAO,EAAI;AjBhBrC,ADbC,AkB8BGA,AFhBJ,AVAA,AMAA,CZzBA,EAaA,CkB4BIA,OAAO,CAACT,KAAR,GAAgB,oBAAhB;AjBhBJ,AiBiBG,AFhBH,AVAA,AMAA,GMcE;AjBdF,AiBkBE,AFjBF,AVAA,AMAA,SMiBSM,YAAP;AjBjBF,ADbA,AkBgCC,AFlBD,AVAA,AMAA,CMbA,QlBDSnN,IAAT,CAAcrB,GAAd,EAAmBsB,KAAnB,EAA0B;ACc1B,ADbI,AgBcJ,AVAA,AMAA,OZdStB,GAAL,GAAWA,GAAX;ACcJ,ADbI,AkBiCJ,AFnBA,AVAA,AMAA,IMmBMyO,GlBjCGnN,KAAL,GAAaA,EkBiCE,GlBjCf,AkBiCkB,SAAhBmN,aAAgB,CAACnN,KAAD,EAAQsN,KAAR,EAAkB;AjBnBxC,ADbC,AkBiCC,AFnBF,AVAA,AMAA,MMmBMC,MAAM,GAAG,EAAb;AjBnBF,AeCA,AVAA,AMAA;AXAA,ADdAxN,AkBiCE,AFlBF,AVAA,AMAA,IZfI,CAACE,EkBiCE,IAAIJ,CAAC,ElBjCZ,CAAeL,AkBiCA8N,GlBjCf,EkBiCE,ClBjCmB,CkBiCCzN,CAAC,GAAG,CAAxB,EAA2BA,CAAC,EAA5B,ClBjC+B,CkBiCC;AjBlBlC,ADdI,AkBiCA0N,AFlBJ,AVAA,AMAA,IMkBIA,GlBjCK7O,GAAL,AkBiCM,ClBjCGwB,AkBiCFJ,IAAP,ClBjCA,AkBiCYE,ClBjCG,IAAf,AkBiCiB,CAACgI,ClBjCG,KAAKhI,AkBiCd,CAAa,CAAb,EAAgB0G,ClBjC5B,GkBiCgC,CAAC8G,IAAL,CAAUxN,KAAK,CAACb,MAAN,GAAeU,CAAzB,CAAhB,CAAZ;AjBlBJ,ADdC,AkBiCE,AFlBH,AVAA,AMAA,CZjBA;ACiBA,AeCA,AVAA,AMAA;AXAA,ADfA/B,AkBiCE,AFjBF,AVAA,AMAA,OZhBO,CAACqC,CkBiCCoN,IlBjCT,EkBiCE,ClBjCc,SAAhB;ACgBA,ADdAzP,AkBgCC,AFjBD,AVAA,AMAA,CMWA,MlB1BO,CAACsC,GAAR,GAAc,EAAd;ACeA,ADdAtC,AgBeA,AVAA,AMAA,OZfO,CAACuC,IAAR,GAAe,EAAf;ACeA,ADdAvC,AkBiCA,AFlBA,AVAA,AMAA,IMkBMyN,GlBjCC,CAACjL,OAAR,GAAkB,CkBiCG,ClBjCrB,EAAsB,AkBiCE,SAAlBiL,eAAkB,CAACkC,cAAD,EAAoB;AjBlB5C,AiBmBE,AFlBF,AVAA,AMAA,MMkBMC,IAAI,GAAG7E,IAAI,CAAC1G,KAAL,CAAW0G,IAAI,CAACC,SAAL,CAAe2E,cAAf,CAAX,CAAX;AjBlBF,ADfA3P,AkBkCE4P,AFlBF,AVAA,AMAA,EMkBEA,IAAI,ClBlCC,CAACnN,CkBkCC6M,OlBlCT,GAAmB,EAAnB,GkBkCwB,CAACM,IAAD,CAAtB;AjBlBF,AeCA,AVAA,AMAA;AXAA,ADfA,AkBkCE,AFlBF,AVAA,AMAA,MMkBMA,GlBlCGlN,CkBkCC,CAACrB,ElBlCX,GAAgB,CAAE,AkBkCZ,GAAc,CAAlB,EAAqB;AjBlBvB,AiBmBI,AFlBJ,AVAA,AMAA,QMkBQwO,IAAI,GAAGD,IAAI,CAACA,IAAI,CAACvO,MAAL,GAAc,CAAf,CAAJ,CAAsBwG,SAAtB,GAAkC+H,IAAI,CAAC,CAAD,CAAJ,CAAQ/H,SAArD;AjBlBJ,ADfA7H,AkBkCI4P,AFlBJ,AVAA,AMAA,IMkBIA,GlBlCG,CAACjN,AkBkCA,CAACkC,ClBlCT,GAAanC,GkBkCT,ClBlCJ,AkBkCiB,UAAC6M,OAAD,EAAa;AjBlB9B,ADfAvP,AkBkCM,AFlBN,AVAA,AMAA,OZhBO,CAAC4C,EkBkCEkN,OAAO,ElBlCjB,CkBkCqB,CAACP,ClBlCA7M,IAAtB,EkBkC6B,CAACmF,SAAR,GAAoB+H,IAAI,CAAC,CAAD,CAAJ,CAAQ/H,SAA7B,IAA0CgI,IAA3C,GAAmD,GAAjE;AjBlBN,ADfA7P,AkBkCMuP,AFlBN,AVAA,AMAA,MMkBMA,ClBlCC,CAAC1M,IAAR,CkBkCa,CAACuJ,ClBlCC1J,IAAf,CkBkCM,GAAiBqN,UAAU,CAACD,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAD,CAAV,GAAiC,CAAlD;AjBlBN,ADfAhQ,AkBkCK,AFlBL,AVAA,AMAA,KMeI,ElB/BG,CAAC8C,GAAR,GAAcJ,IAAd;ACgBA,ADfA1C,AkBkCG,AFlBH,AVAA,AMAA,OZhBO,CAAC+C,cAAR,GAAyBL,IAAzB;ACgBA,ADfA1C,AgBgBA,AVAA,AMAA,OZhBO,CAACgD,kBAAR,GAA6BN,IAA7B;ACgBA,ADfA1C,AkBkCE,AFlBF,AVAA,AMAA,OZhBO,CAACiD,CkBkCC2M,GlBlCT,CkBkCE,ElBlCalN,IAAf;ACgBA,ADfA1C,AkBkCC,AFlBD,AVAA,AMAA,CMKA,MlBrBO,CAACkD,eAAR,GAA0BR,IAA1B;ACgBA,ADfA1C,AgBgBA,AVAA,AMAA,OZhBO,CAACmD,mBAAR,GAA8BT,IAA9B;ACgBA,AiBmBA,AFlBA,AVAA,AMAA,IMkBMuN,YAAY,GAAG,SAAfA,YAAe,GAAM;AjBlB3B,ADfAjQ,AkBkCEsL,AFlBF,AVAA,AMAA,EMkBEA,KlBlCK,CAAClI,SAAR,GAAoB,AkBkCA,CAACmJ,SlBlCSlJ,IAAV,EAAgB,CkBkClC,CAAoC,OAApC,EAA6C,YAAM;AjBlBrD,ADhBsC,AkBmClC,AFlBJ,AVAA,QYkBQ6M,ClBnCqC,EAAP,OkBmCpB,GAAG3E,QAAQ,CAAC4E,aAAT,CAAuB,QAAvB,EAAiCC,KAAlD;AjBlBJ,ADjBiD,AgBkBjD,AVAA,CNlBA;ACkBA,AiBkBI,AFjBJ,AVAA,QYiBQF,UAAU,IAAI,GAAd,IAAqBA,UAAU,GAAG,CAAtC,EAAyC;AjBjB7C,ADjBAlQ,AkBmCM4L,AFjBN,AVAA,MYiBMA,ClBnCC,CAACtI,IkBmCI,GlBnCZ,AkBmCe4M,GlBnCG,OkBmCZ,GlBnCsB7M,IAAV,EAAgB;ACkBlC,ADjBI,AkBmCEsI,AFjBN,AVAA,MYiBMA,ElBnCI,IAAIrL,CkBmCD,CAAC2O,GlBnCJ,AkBmCJ,ClBnCc,AkBmCF,QAAZ,EAAsBtD,OAAO,CAACuD,GAAR,CAAY,QAAZ,IlBnClB,AkBmC0CtD,ClBnChD,KkBmCwB,GAAiCA,MAAvD;AjBjBN,ADjBC,AkBmCI,AFjBL,AVAA,CNpBA;ACoBA,AiBkBG,AFjBH,AVAA,GYWE;AjBXF,ADjBA5L,AkBmCC,AFjBD,AVAA,CYSA,MlB3BO,CAACuD,GAAR,GAAc,YAAY;ACkB1B,ADlB4B,AkBqC5B,AFlBA,AVAA,SNnBmC,GAAP;ACmB5B,ADnBwC,AgBoBxC,AVAA,CNpBA;ACoBA,AeCA,AVAA;ALAA,ADpBAvD,AgBqBA,AVAA,ONrBO,CAACwD,KAAR,GAAgB,UAAUC,GAAV,EAAe;ACqB/B,ADpBI,AgBqBJ,AVAA,QNrBU,IAAInD,KAAJ,CAAU,gCAAV,CAAN;ACqBJ,ADpBC,AkBsCD,AFjBA,AVAA,CNvBA,GkBwCMoN,2BAA2B,GAAG,SAA9BA,2BAA8B,GAAM;AjBjB1C,AiBmBEhC,AFlBF,AVAA,EYkBEA,UAAU,CAAC2E,KAAX,CAAiBzN,WAAjB,CAA6B6I,GAA7B,EAAkC,OAAlC,EAA2C,UAAC4E,KAAD,EAAW;AjBlBxD,ADrBArQ,AkBwCIsQ,AFlBJ,AVAA,IYkBIA,GlBxCG,AkBwCA,ClBxCC5M,AkBwCA1B,IAAJ,ClBxCJ,AkBwCa,GlBxCG,YAAW;ACsB3B,ADtB6B,AkByCvB+H,AFlBN,AVAA,MYkBMA,GlBzC8B,CAAP,IkByCf,EAAE,IAAIiC,MAAM,CAACC,MAAP,CAAcC,IAAd,CAAmBC,MAAvB,CAA8B;AjBlB9C,ADvBwC,AkB0ChC9D,AFlBR,AVAA,CNxBA,OkB0CQA,GAAG,EAAEgI,KAAK,CAACE,MAAN,CAAalI,GAAb,EADiC;AjBjB9C,AiBmBQE,AFlBR,AVAA,QYkBQA,GAAG,EAAE8H,KAAK,CAACE,MAAN,CAAahI,GAAb;AjBlBb,AiBgB8C,AFf9C,AVAA,OYegB,CADH;AjBdb,AiBmBM6D,AFlBN,AVAA,MYkBMA,MAAM,EAAE,CALD;AjBbb,AiBmBMvE,AFlBN,AVAA,MYkBMA,SAAS,EAAED,IAAI,CAAC4I,GAAL;AjBlBjB,AiBYa,AFXb,AVAA,KYWI;AjBXJ,AiBoBI7E,AFnBJ,AVAA,IYmBIA,OAAO,CAACgD,MAAR,CAAe,IAAf;AjBnBJ,AiBqBInB,AFpBJ,AVAA,IYoBIA,kBAAkB,CAAC3B,uBAAuB,CAAC4B,eAAe,CAAC6C,GAAD,CAAhB,CAAxB,CAAlB;AjBpBJ,AiBqBG,AFpBH,AVAA,GYOE;AjBPF,AiBqBC,AFpBD,AVAA,CYIA;AjBJA,AeCA,AVAA;ALAA,AiBsBA,AFrBA,AVAA,IYqBMhB,eAAe,GAAG,SAAlBA,eAAkB,CAAC9H,WAAD,EAAiB;AjBrBzC,AiBsBE,AFrBF,AVAA,SYqBSA,WAAW,CAACf,IAAZ,CAAiB,UAAUW,CAAV,EAAaC,CAAb,EAAgB;AjBrB1C,AiBsBI,AFrBJ,AVAA,WYqBWD,CAAC,CAACS,SAAF,GAAcR,CAAC,CAACQ,SAAvB;AjBrBJ,AiBsBG,AFrBH,AVAA,GYmBS,CAAP;AjBnBF,AiBsBC,AFrBD,AVAA,CYiBA;AjBjBA,AeCA,AVAA;ALAA,AiBsBAwE,AFrBA,AVAA,OYqBO;AjBrBP,AiBsBA4D,AFrBA,AVAA,YYqBY;AjBrBZ,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;ALAA,AeCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AUCA,AVAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.c328ef1a.js","sourceRoot":"..","sourcesContent":["// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nconst fs = require('fs')\nconst path = require('path')\n\nfunction log (message /*: string */) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nconst NEWLINE = '\\n'\nconst RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/\nconst RE_NEWLINES = /\\\\n/g\nconst NEWLINES_MATCH = /\\n|\\r|\\r\\n/\n\n// Parses src into an Object\nfunction parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {\n  const debug = Boolean(options && options.debug)\n  const obj = {}\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(RE_INI_KEY_VAL)\n    // matched?\n    if (keyValueArr != null) {\n      const key = keyValueArr[1]\n      // default undefined or missing values to empty string\n      let val = (keyValueArr[2] || '')\n      const end = val.length - 1\n      const isDoubleQuoted = val[0] === '\"' && val[end] === '\"'\n      const isSingleQuoted = val[0] === \"'\" && val[end] === \"'\"\n\n      // if single or double quoted, remove quotes\n      if (isSingleQuoted || isDoubleQuoted) {\n        val = val.substring(1, end)\n\n        // if double quoted, expand newlines\n        if (isDoubleQuoted) {\n          val = val.replace(RE_NEWLINES, NEWLINE)\n        }\n      } else {\n        // remove surrounding whitespace\n        val = val.trim()\n      }\n\n      obj[key] = val\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)\n    }\n  })\n\n  return obj\n}\n\n// Populates process.env from .env file\nfunction config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding /*: string */ = 'utf8'\n  let debug = false\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = options.path\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n    if (options.debug != null) {\n      debug = true\n    }\n  }\n\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`)\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    return { error: e }\n  }\n}\n\nmodule.exports.config = config\nmodule.exports.parse = parse\n","const API_URL = 'https://maps.googleapis.com/maps/api/js'\nconst CALLBACK_NAME = '__googleMapsApiOnLoadCallback'\n\nconst optionsKeys = ['channel', 'client', 'key', 'language', 'region', 'v']\n\nlet promise = null\n\nmodule.exports = function (options = {}) {\n  promise =\n    promise ||\n    new Promise(function (resolve, reject) {\n      // Reject the promise after a timeout\n      const timeoutId = setTimeout(function () {\n        window[CALLBACK_NAME] = function () {} // Set the on load callback to a no-op\n        reject(new Error('Could not load the Google Maps API'))\n      }, options.timeout || 10000)\n\n      // Hook up the on load callback\n      window[CALLBACK_NAME] = function () {\n        if (timeoutId !== null) {\n          clearTimeout(timeoutId)\n        }\n        resolve(window.google.maps)\n        delete window[CALLBACK_NAME]\n      }\n\n      // Prepare the `script` tag to be inserted into the page\n      const scriptElement = document.createElement('script')\n      const params = [`callback=${CALLBACK_NAME}`]\n      optionsKeys.forEach(function (key) {\n        if (options[key]) {\n          params.push(`${key}=${options[key]}`)\n        }\n      })\n      if (options.libraries && options.libraries.length) {\n        params.push(`libraries=${options.libraries.join(',')}`)\n      }\n      scriptElement.src = `${options.apiUrl || API_URL}?${params.join('&')}`\n\n      // Insert the `script` tag\n      document.body.appendChild(scriptElement)\n    })\n  return promise\n}\n","/* \n * Convex hull algorithm - Library (JavaScript)\n * \n * Copyright (c) 2018 Project Nayuki\n * https://www.nayuki.io/page/convex-hull-algorithm\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program (see COPYING.txt and COPYING.LESSER.txt).\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\n\"use strict\";\n\n\nvar convexhull = new function () {\n\n    // Returns a new array of points representing the convex hull of\n    // the given set of points. The convex hull excludes collinear points.\n    // This algorithm runs in O(n log n) time.\n    this.makeHull = function (points) {\n        var newPoints = points.slice();\n        newPoints.sort(this.POINT_COMPARATOR);\n        return this.makeHullPresorted(newPoints);\n    };\n\n\n    // Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\n    this.makeHullPresorted = function (points) {\n        if (points.length <= 1)\n            return points.slice();\n\n        // Andrew's monotone chain algorithm. Positive y coordinates correspond to \"up\"\n        // as per the mathematical convention, instead of \"down\" as per the computer\n        // graphics convention. This doesn't affect the correctness of the result.\n\n        var upperHull = [];\n        for (var i = 0; i < points.length; i++) {\n            var p = points[i];\n            while (upperHull.length >= 2) {\n                var q = upperHull[upperHull.length - 1];\n                var r = upperHull[upperHull.length - 2];\n                if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n                    upperHull.pop();\n                else\n                    break;\n            }\n            upperHull.push(p);\n        }\n        upperHull.pop();\n\n        var lowerHull = [];\n        for (var i = points.length - 1; i >= 0; i--) {\n            var p = points[i];\n            while (lowerHull.length >= 2) {\n                var q = lowerHull[lowerHull.length - 1];\n                var r = lowerHull[lowerHull.length - 2];\n                if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n                    lowerHull.pop();\n                else\n                    break;\n            }\n            lowerHull.push(p);\n        }\n        lowerHull.pop();\n\n        if (upperHull.length == 1 && lowerHull.length == 1 && upperHull[0].x == lowerHull[0].x && upperHull[0].y == lowerHull[0].y)\n            return upperHull;\n        else\n            return upperHull.concat(lowerHull);\n    };\n\n\n    this.POINT_COMPARATOR = function (a, b) {\n        if (a.x < b.x)\n            return -1;\n        else if (a.x > b.x)\n            return +1;\n        else if (a.y < b.y)\n            return -1;\n        else if (a.y > b.y)\n            return +1;\n        else\n            return 0;\n    };\n\n};\nmodule.exports = convexhull\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n","'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","\"use strict\"\n\nmodule.exports = twoProduct\n\nvar SPLITTER = +(Math.pow(2, 27) + 1.0)\n\nfunction twoProduct(a, b, result) {\n  var x = a * b\n\n  var c = SPLITTER * a\n  var abig = c - a\n  var ahi = c - abig\n  var alo = a - ahi\n\n  var d = SPLITTER * b\n  var bbig = d - b\n  var bhi = d - bbig\n  var blo = b - bhi\n\n  var err1 = x - (ahi * bhi)\n  var err2 = err1 - (alo * bhi)\n  var err3 = err2 - (ahi * blo)\n\n  var y = alo * blo - err3\n\n  if(result) {\n    result[0] = y\n    result[1] = x\n    return result\n  }\n\n  return [ y, x ]\n}","\"use strict\"\n\nmodule.exports = linearExpansionSum\n\n//Easy case: Add two scalars\nfunction scalarScalar(a, b) {\n  var x = a + b\n  var bv = x - a\n  var av = x - bv\n  var br = b - bv\n  var ar = a - av\n  var y = ar + br\n  if(y) {\n    return [y, x]\n  }\n  return [x]\n}\n\nfunction linearExpansionSum(e, f) {\n  var ne = e.length|0\n  var nf = f.length|0\n  if(ne === 1 && nf === 1) {\n    return scalarScalar(e[0], f[0])\n  }\n  var n = ne + nf\n  var g = new Array(n)\n  var count = 0\n  var eptr = 0\n  var fptr = 0\n  var abs = Math.abs\n  var ei = e[eptr]\n  var ea = abs(ei)\n  var fi = f[fptr]\n  var fa = abs(fi)\n  var a, b\n  if(ea < fa) {\n    b = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    b = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n      fa = abs(fi)\n    }\n  }\n  if((eptr < ne && ea < fa) || (fptr >= nf)) {\n    a = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    a = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n      fa = abs(fi)\n    }\n  }\n  var x = a + b\n  var bv = x - a\n  var y = b - bv\n  var q0 = y\n  var q1 = x\n  var _x, _bv, _av, _br, _ar\n  while(eptr < ne && fptr < nf) {\n    if(ea < fa) {\n      a = ei\n      eptr += 1\n      if(eptr < ne) {\n        ei = e[eptr]\n        ea = abs(ei)\n      }\n    } else {\n      a = fi\n      fptr += 1\n      if(fptr < nf) {\n        fi = f[fptr]\n        fa = abs(fi)\n      }\n    }\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n  }\n  while(eptr < ne) {\n    a = ei\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n    }\n  }\n  while(fptr < nf) {\n    a = fi\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    } \n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n    }\n  }\n  if(q0) {\n    g[count++] = q0\n  }\n  if(q1) {\n    g[count++] = q1\n  }\n  if(!count) {\n    g[count++] = 0.0  \n  }\n  g.length = count\n  return g\n}","\"use strict\"\n\nmodule.exports = fastTwoSum\n\nfunction fastTwoSum(a, b, result) {\n\tvar x = a + b\n\tvar bv = x - a\n\tvar av = x - bv\n\tvar br = b - bv\n\tvar ar = a - av\n\tif(result) {\n\t\tresult[0] = ar + br\n\t\tresult[1] = x\n\t\treturn result\n\t}\n\treturn [ar+br, x]\n}","\"use strict\"\n\nvar twoProduct = require(\"two-product\")\nvar twoSum = require(\"two-sum\")\n\nmodule.exports = scaleLinearExpansion\n\nfunction scaleLinearExpansion(e, scale) {\n  var n = e.length\n  if(n === 1) {\n    var ts = twoProduct(e[0], scale)\n    if(ts[0]) {\n      return ts\n    }\n    return [ ts[1] ]\n  }\n  var g = new Array(2 * n)\n  var q = [0.1, 0.1]\n  var t = [0.1, 0.1]\n  var count = 0\n  twoProduct(e[0], scale, q)\n  if(q[0]) {\n    g[count++] = q[0]\n  }\n  for(var i=1; i<n; ++i) {\n    twoProduct(e[i], scale, t)\n    var pq = q[1]\n    twoSum(pq, t[0], q)\n    if(q[0]) {\n      g[count++] = q[0]\n    }\n    var a = t[1]\n    var b = q[1]\n    var x = a + b\n    var bv = x - a\n    var y = b - bv\n    q[1] = x\n    if(y) {\n      g[count++] = y\n    }\n  }\n  if(q[1]) {\n    g[count++] = q[1]\n  }\n  if(count === 0) {\n    g[count++] = 0.0\n  }\n  g.length = count\n  return g\n}","\"use strict\"\n\nmodule.exports = robustSubtract\n\n//Easy case: Add two scalars\nfunction scalarScalar(a, b) {\n  var x = a + b\n  var bv = x - a\n  var av = x - bv\n  var br = b - bv\n  var ar = a - av\n  var y = ar + br\n  if(y) {\n    return [y, x]\n  }\n  return [x]\n}\n\nfunction robustSubtract(e, f) {\n  var ne = e.length|0\n  var nf = f.length|0\n  if(ne === 1 && nf === 1) {\n    return scalarScalar(e[0], -f[0])\n  }\n  var n = ne + nf\n  var g = new Array(n)\n  var count = 0\n  var eptr = 0\n  var fptr = 0\n  var abs = Math.abs\n  var ei = e[eptr]\n  var ea = abs(ei)\n  var fi = -f[fptr]\n  var fa = abs(fi)\n  var a, b\n  if(ea < fa) {\n    b = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    b = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n      fa = abs(fi)\n    }\n  }\n  if((eptr < ne && ea < fa) || (fptr >= nf)) {\n    a = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    a = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n      fa = abs(fi)\n    }\n  }\n  var x = a + b\n  var bv = x - a\n  var y = b - bv\n  var q0 = y\n  var q1 = x\n  var _x, _bv, _av, _br, _ar\n  while(eptr < ne && fptr < nf) {\n    if(ea < fa) {\n      a = ei\n      eptr += 1\n      if(eptr < ne) {\n        ei = e[eptr]\n        ea = abs(ei)\n      }\n    } else {\n      a = fi\n      fptr += 1\n      if(fptr < nf) {\n        fi = -f[fptr]\n        fa = abs(fi)\n      }\n    }\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n  }\n  while(eptr < ne) {\n    a = ei\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n    }\n  }\n  while(fptr < nf) {\n    a = fi\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    } \n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n    }\n  }\n  if(q0) {\n    g[count++] = q0\n  }\n  if(q1) {\n    g[count++] = q1\n  }\n  if(!count) {\n    g[count++] = 0.0  \n  }\n  g.length = count\n  return g\n}","\"use strict\"\n\nvar twoProduct = require(\"two-product\")\nvar robustSum = require(\"robust-sum\")\nvar robustScale = require(\"robust-scale\")\nvar robustSubtract = require(\"robust-subtract\")\n\nvar NUM_EXPAND = 5\n\nvar EPSILON     = 1.1102230246251565e-16\nvar ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON\nvar ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON\n\nfunction cofactor(m, c) {\n  var result = new Array(m.length-1)\n  for(var i=1; i<m.length; ++i) {\n    var r = result[i-1] = new Array(m.length-1)\n    for(var j=0,k=0; j<m.length; ++j) {\n      if(j === c) {\n        continue\n      }\n      r[k++] = m[i][j]\n    }\n  }\n  return result\n}\n\nfunction matrix(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = new Array(n)\n    for(var j=0; j<n; ++j) {\n      result[i][j] = [\"m\", j, \"[\", (n-i-1), \"]\"].join(\"\")\n    }\n  }\n  return result\n}\n\nfunction sign(n) {\n  if(n & 1) {\n    return \"-\"\n  }\n  return \"\"\n}\n\nfunction generateSum(expr) {\n  if(expr.length === 1) {\n    return expr[0]\n  } else if(expr.length === 2) {\n    return [\"sum(\", expr[0], \",\", expr[1], \")\"].join(\"\")\n  } else {\n    var m = expr.length>>1\n    return [\"sum(\", generateSum(expr.slice(0, m)), \",\", generateSum(expr.slice(m)), \")\"].join(\"\")\n  }\n}\n\nfunction determinant(m) {\n  if(m.length === 2) {\n    return [[\"sum(prod(\", m[0][0], \",\", m[1][1], \"),prod(-\", m[0][1], \",\", m[1][0], \"))\"].join(\"\")]\n  } else {\n    var expr = []\n    for(var i=0; i<m.length; ++i) {\n      expr.push([\"scale(\", generateSum(determinant(cofactor(m, i))), \",\", sign(i), m[0][i], \")\"].join(\"\"))\n    }\n    return expr\n  }\n}\n\nfunction orientation(n) {\n  var pos = []\n  var neg = []\n  var m = matrix(n)\n  var args = []\n  for(var i=0; i<n; ++i) {\n    if((i&1)===0) {\n      pos.push.apply(pos, determinant(cofactor(m, i)))\n    } else {\n      neg.push.apply(neg, determinant(cofactor(m, i)))\n    }\n    args.push(\"m\" + i)\n  }\n  var posExpr = generateSum(pos)\n  var negExpr = generateSum(neg)\n  var funcName = \"orientation\" + n + \"Exact\"\n  var code = [\"function \", funcName, \"(\", args.join(), \"){var p=\", posExpr, \",n=\", negExpr, \",d=sub(p,n);\\\nreturn d[d.length-1];};return \", funcName].join(\"\")\n  var proc = new Function(\"sum\", \"prod\", \"scale\", \"sub\", code)\n  return proc(robustSum, twoProduct, robustScale, robustSubtract)\n}\n\nvar orientation3Exact = orientation(3)\nvar orientation4Exact = orientation(4)\n\nvar CACHED = [\n  function orientation0() { return 0 },\n  function orientation1() { return 0 },\n  function orientation2(a, b) { \n    return b[0] - a[0]\n  },\n  function orientation3(a, b, c) {\n    var l = (a[1] - c[1]) * (b[0] - c[0])\n    var r = (a[0] - c[0]) * (b[1] - c[1])\n    var det = l - r\n    var s\n    if(l > 0) {\n      if(r <= 0) {\n        return det\n      } else {\n        s = l + r\n      }\n    } else if(l < 0) {\n      if(r >= 0) {\n        return det\n      } else {\n        s = -(l + r)\n      }\n    } else {\n      return det\n    }\n    var tol = ERRBOUND3 * s\n    if(det >= tol || det <= -tol) {\n      return det\n    }\n    return orientation3Exact(a, b, c)\n  },\n  function orientation4(a,b,c,d) {\n    var adx = a[0] - d[0]\n    var bdx = b[0] - d[0]\n    var cdx = c[0] - d[0]\n    var ady = a[1] - d[1]\n    var bdy = b[1] - d[1]\n    var cdy = c[1] - d[1]\n    var adz = a[2] - d[2]\n    var bdz = b[2] - d[2]\n    var cdz = c[2] - d[2]\n    var bdxcdy = bdx * cdy\n    var cdxbdy = cdx * bdy\n    var cdxady = cdx * ady\n    var adxcdy = adx * cdy\n    var adxbdy = adx * bdy\n    var bdxady = bdx * ady\n    var det = adz * (bdxcdy - cdxbdy) \n            + bdz * (cdxady - adxcdy)\n            + cdz * (adxbdy - bdxady)\n    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)\n                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)\n                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)\n    var tol = ERRBOUND4 * permanent\n    if ((det > tol) || (-det > tol)) {\n      return det\n    }\n    return orientation4Exact(a,b,c,d)\n  }\n]\n\nfunction slowOrient(args) {\n  var proc = CACHED[args.length]\n  if(!proc) {\n    proc = CACHED[args.length] = orientation(args.length)\n  }\n  return proc.apply(undefined, args)\n}\n\nfunction generateOrientationProc() {\n  while(CACHED.length <= NUM_EXPAND) {\n    CACHED.push(orientation(CACHED.length))\n  }\n  var args = []\n  var procArgs = [\"slow\"]\n  for(var i=0; i<=NUM_EXPAND; ++i) {\n    args.push(\"a\" + i)\n    procArgs.push(\"o\" + i)\n  }\n  var code = [\n    \"function getOrientation(\", args.join(), \"){switch(arguments.length){case 0:case 1:return 0;\"\n  ]\n  for(var i=2; i<=NUM_EXPAND; ++i) {\n    code.push(\"case \", i, \":return o\", i, \"(\", args.slice(0, i).join(), \");\")\n  }\n  code.push(\"}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation\")\n  procArgs.push(code.join(\"\"))\n\n  var proc = Function.apply(undefined, procArgs)\n  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))\n  for(var i=0; i<=NUM_EXPAND; ++i) {\n    module.exports[i] = CACHED[i]\n  }\n}\n\ngenerateOrientationProc()","'use strict'\n\nmodule.exports = monotoneConvexHull2D\n\nvar orient = require('robust-orientation')[3]\n\nfunction monotoneConvexHull2D(points) {\n  var n = points.length\n\n  if(n < 3) {\n    var result = new Array(n)\n    for(var i=0; i<n; ++i) {\n      result[i] = i\n    }\n\n    if(n === 2 &&\n       points[0][0] === points[1][0] &&\n       points[0][1] === points[1][1]) {\n      return [0]\n    }\n\n    return result\n  }\n\n  //Sort point indices along x-axis\n  var sorted = new Array(n)\n  for(var i=0; i<n; ++i) {\n    sorted[i] = i\n  }\n  sorted.sort(function(a,b) {\n    var d = points[a][0]-points[b][0]\n    if(d) {\n      return d\n    }\n    return points[a][1] - points[b][1]\n  })\n\n  //Construct upper and lower hulls\n  var lower = [sorted[0], sorted[1]]\n  var upper = [sorted[0], sorted[1]]\n\n  for(var i=2; i<n; ++i) {\n    var idx = sorted[i]\n    var p   = points[idx]\n\n    //Insert into lower list\n    var m = lower.length\n    while(m > 1 && orient(\n        points[lower[m-2]], \n        points[lower[m-1]], \n        p) <= 0) {\n      m -= 1\n      lower.pop()\n    }\n    lower.push(idx)\n\n    //Insert into upper list\n    m = upper.length\n    while(m > 1 && orient(\n        points[upper[m-2]], \n        points[upper[m-1]], \n        p) >= 0) {\n      m -= 1\n      upper.pop()\n    }\n    upper.push(idx)\n  }\n\n  //Merge lists together\n  var result = new Array(upper.length + lower.length - 2)\n  var ptr    = 0\n  for(var i=0, nl=lower.length; i<nl; ++i) {\n    result[ptr++] = lower[i]\n  }\n  for(var j=upper.length-2; j>0; --j) {\n    result[ptr++] = upper[j]\n  }\n\n  //Return result\n  return result\n}","'use strict';\n\nmodule.exports = TinyQueue;\nmodule.exports.default = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n\n        var top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var halfLength = this.length >> 1;\n        var item = data[pos];\n\n        while (pos < halfLength) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n","module.exports = function (point, vs) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n    \n    var x = point[0], y = point[1];\n    \n    var inside = false;\n    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n        var xi = vs[i][0], yi = vs[i][1];\n        var xj = vs[j][0], yj = vs[j][1];\n        \n        var intersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    \n    return inside;\n};\n","'use strict';\n\nvar rbush = require('rbush');\nvar convexHull = require('monotone-convex-hull-2d');\nvar Queue = require('tinyqueue');\nvar pointInPolygon = require('point-in-polygon');\nvar orient = require('robust-orientation')[3];\n\nmodule.exports = concaveman;\nmodule.exports.default = concaveman;\n\nfunction concaveman(points, concavity, lengthThreshold) {\n    // a relative measure of concavity; higher value means simpler hull\n    concavity = Math.max(0, concavity === undefined ? 2 : concavity);\n\n    // when a segment goes below this length threshold, it won't be drilled down further\n    lengthThreshold = lengthThreshold || 0;\n\n    // start with a convex hull of the points\n    var hull = fastConvexHull(points);\n\n    // index the points with an R-tree\n    var tree = rbush(16, ['[0]', '[1]', '[0]', '[1]']).load(points);\n\n    // turn the convex hull into a linked list and populate the initial edge queue with the nodes\n    var queue = [];\n    for (var i = 0, last; i < hull.length; i++) {\n        var p = hull[i];\n        tree.remove(p);\n        last = insertNode(p, last);\n        queue.push(last);\n    }\n\n    // index the segments with an R-tree (for intersection checks)\n    var segTree = rbush(16);\n    for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));\n\n    var sqConcavity = concavity * concavity;\n    var sqLenThreshold = lengthThreshold * lengthThreshold;\n\n    // process edges one by one\n    while (queue.length) {\n        var node = queue.shift();\n        var a = node.p;\n        var b = node.next.p;\n\n        // skip the edge if it's already short enough\n        var sqLen = getSqDist(a, b);\n        if (sqLen < sqLenThreshold) continue;\n\n        var maxSqLen = sqLen / sqConcavity;\n\n        // find the best connection point for the current edge to flex inward to\n        p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);\n\n        // if we found a connection and it satisfies our concavity measure\n        if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\n            // connect the edge endpoints through this point and add 2 new edges to the queue\n            queue.push(node);\n            queue.push(insertNode(p, node));\n\n            // update point and segment indexes\n            tree.remove(p);\n            segTree.remove(node);\n            segTree.insert(updateBBox(node));\n            segTree.insert(updateBBox(node.next));\n        }\n    }\n\n    // convert the resulting hull linked list to an array of points\n    node = last;\n    var concave = [];\n    do {\n        concave.push(node.p);\n        node = node.next;\n    } while (node !== last);\n\n    concave.push(node.p);\n\n    return concave;\n}\n\nfunction findCandidate(tree, a, b, c, d, maxDist, segTree) {\n    var queue = new Queue(null, compareDist);\n    var node = tree.data;\n\n    // search through the point R-tree with a depth-first search using a priority queue\n    // in the order of distance to the edge (b, c)\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n\n            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\n            if (dist > maxDist) continue; // skip the node if it's farther than we ever need\n\n            queue.push({\n                node: child,\n                dist: dist\n            });\n        }\n\n        while (queue.length && !queue.peek().node.children) {\n            var item = queue.pop();\n            var p = item.node;\n\n            // skip all points that are as close to adjacent edges (a,b) and (c,d),\n            // and points that would introduce self-intersections when connected\n            var d0 = sqSegDist(p, a, b);\n            var d1 = sqSegDist(p, c, d);\n            if (item.dist < d0 && item.dist < d1 &&\n                noIntersections(b, p, segTree) &&\n                noIntersections(c, p, segTree)) return p;\n        }\n\n        node = queue.pop();\n        if (node) node = node.node;\n    }\n\n    return null;\n}\n\nfunction compareDist(a, b) {\n    return a.dist - b.dist;\n}\n\n// square distance from a segment bounding box to the given one\nfunction sqSegBoxDist(a, b, bbox) {\n    if (inside(a, bbox) || inside(b, bbox)) return 0;\n    var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);\n    if (d1 === 0) return 0;\n    var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);\n    if (d2 === 0) return 0;\n    var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);\n    if (d3 === 0) return 0;\n    var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);\n    if (d4 === 0) return 0;\n    return Math.min(d1, d2, d3, d4);\n}\n\nfunction inside(a, bbox) {\n    return a[0] >= bbox.minX &&\n           a[0] <= bbox.maxX &&\n           a[1] >= bbox.minY &&\n           a[1] <= bbox.maxY;\n}\n\n// check if the edge (a,b) doesn't intersect any other edges\nfunction noIntersections(a, b, segTree) {\n    var minX = Math.min(a[0], b[0]);\n    var minY = Math.min(a[1], b[1]);\n    var maxX = Math.max(a[0], b[0]);\n    var maxY = Math.max(a[1], b[1]);\n\n    var edges = segTree.search({minX: minX, minY: minY, maxX: maxX, maxY: maxY});\n    for (var i = 0; i < edges.length; i++) {\n        if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\n    }\n    return true;\n}\n\n// check if the edges (p1,q1) and (p2,q2) intersect\nfunction intersects(p1, q1, p2, q2) {\n    return p1 !== q2 && q1 !== p2 &&\n        orient(p1, q1, p2) > 0 !== orient(p1, q1, q2) > 0 &&\n        orient(p2, q2, p1) > 0 !== orient(p2, q2, q1) > 0;\n}\n\n// update the bounding box of a node's edge\nfunction updateBBox(node) {\n    var p1 = node.p;\n    var p2 = node.next.p;\n    node.minX = Math.min(p1[0], p2[0]);\n    node.minY = Math.min(p1[1], p2[1]);\n    node.maxX = Math.max(p1[0], p2[0]);\n    node.maxY = Math.max(p1[1], p2[1]);\n    return node;\n}\n\n// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\nfunction fastConvexHull(points) {\n    var left = points[0];\n    var top = points[0];\n    var right = points[0];\n    var bottom = points[0];\n\n    // find the leftmost, rightmost, topmost and bottommost points\n    for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        if (p[0] < left[0]) left = p;\n        if (p[0] > right[0]) right = p;\n        if (p[1] < top[1]) top = p;\n        if (p[1] > bottom[1]) bottom = p;\n    }\n\n    // filter out points that are inside the resulting quadrilateral\n    var cull = [left, top, right, bottom];\n    var filtered = cull.slice();\n    for (i = 0; i < points.length; i++) {\n        if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);\n    }\n\n    // get convex hull around the filtered points\n    var indices = convexHull(filtered);\n\n    // return the hull as array of points (rather than indices)\n    var hull = [];\n    for (i = 0; i < indices.length; i++) hull.push(filtered[indices[i]]);\n    return hull;\n}\n\n// create a new node in a doubly linked list\nfunction insertNode(p, prev) {\n    var node = {\n        p: p,\n        prev: null,\n        next: null,\n        minX: 0,\n        minY: 0,\n        maxX: 0,\n        maxY: 0\n    };\n\n    if (!prev) {\n        node.prev = node;\n        node.next = node;\n\n    } else {\n        node.next = prev.next;\n        node.prev = prev;\n        prev.next.prev = node;\n        prev.next = node;\n    }\n    return node;\n}\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1[0] - p2[0],\n        dy = p1[1] - p2[1];\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction sqSegDist(p, p1, p2) {\n\n    var x = p1[0],\n        y = p1[1],\n        dx = p2[0] - x,\n        dy = p2[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2[0];\n            y = p2[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p[0] - x;\n    dy = p[1] - y;\n\n    return dx * dx + dy * dy;\n}\n\n// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\nfunction sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\n    var ux = x1 - x0;\n    var uy = y1 - y0;\n    var vx = x3 - x2;\n    var vy = y3 - y2;\n    var wx = x0 - x2;\n    var wy = y0 - y2;\n    var a = ux * ux + uy * uy;\n    var b = ux * vx + uy * vy;\n    var c = vx * vx + vy * vy;\n    var d = ux * wx + uy * wy;\n    var e = vx * wx + vy * wy;\n    var D = a * c - b * b;\n\n    var sc, sN, tc, tN;\n    var sD = D;\n    var tD = D;\n\n    if (D === 0) {\n        sN = 0;\n        sD = 1;\n        tN = e;\n        tD = c;\n    } else {\n        sN = b * e - c * d;\n        tN = a * e - b * d;\n        if (sN < 0) {\n            sN = 0;\n            tN = e;\n            tD = c;\n        } else if (sN > sD) {\n            sN = sD;\n            tN = e + b;\n            tD = c;\n        }\n    }\n\n    if (tN < 0.0) {\n        tN = 0.0;\n        if (-d < 0.0) sN = 0.0;\n        else if (-d > a) sN = sD;\n        else {\n            sN = -d;\n            sD = a;\n        }\n    } else if (tN > tD) {\n        tN = tD;\n        if ((-d + b) < 0.0) sN = 0;\n        else if (-d + b > a) sN = sD;\n        else {\n            sN = -d + b;\n            sD = a;\n        }\n    }\n\n    sc = sN === 0 ? 0 : sN / sD;\n    tc = tN === 0 ? 0 : tN / tD;\n\n    var cx = (1 - sc) * x0 + sc * x1;\n    var cy = (1 - sc) * y0 + sc * y1;\n    var cx2 = (1 - tc) * x2 + tc * x3;\n    var cy2 = (1 - tc) * y2 + tc * y3;\n    var dx = cx2 - cx;\n    var dy = cy2 - cy;\n\n    return dx * dx + dy * dy;\n}\n","const convexhull = require('./convec_hull')\nconst concaveman = require('concaveman')\n\n\nfunction splitByTimestamp(coordinates) {\n    let coordinatesByTime = {}\n    coordinates.forEach(c => {\n        let time = new Date(c.timestamp)\n        let h = time.getHours()\n        let timeName = h.toString() + ':00-' + h.toString() + ':59'\n        if (!coordinatesByTime[timeName]) {\n            coordinatesByTime[timeName] = []\n        }\n        coordinatesByTime[timeName].push(c)\n    });\n    return coordinatesByTime\n}\n\nfunction measure(coord1, coord2) {  // generally used geo measurement function\n    let lat1 = coord1.lat\n    let lon1 = coord1.lng\n    let lat2 = coord2.lat\n    let lon2 = coord2.lng\n\n    var R = 6378.137; // Radius of earth in KM\n    var dLat = lat2 * Math.PI / 180 - lat1 * Math.PI / 180;\n    var dLon = lon2 * Math.PI / 180 - lon1 * Math.PI / 180;\n    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n        Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    var d = R * c;\n    return d * 1000; // meters\n}\n\n\n\nfunction coordinateIsIn(coordinate, coordinateGroups) {\n    let index = -1\n    coordinateGroups.forEach((polygon, i) => {\n        if (polygon.includes(coordinate)) {\n            index = i\n            return\n        }\n    });\n    return index\n}\n\nfunction groupCoordinatesByDistance(coordinates, allowedDistance) {\n    let coordinateGroups = []\n    for (let i = 0; i < coordinates.length; i++) {\n        let c = coordinates\n        let iPolygonIndex = coordinateIsIn(c[i], coordinateGroups)\n        if (iPolygonIndex < 0) {\n            coordinateGroups.push([c[i]])\n            iPolygonIndex = coordinateGroups.length - 1\n        }\n        for (let j = 0; j < coordinates.length; j++) {\n            if (!(i === j)) {\n                let distance = measure(c[i].location, c[j].location)\n                if (distance <= allowedDistance) {\n                    let jPolygonIndex = coordinateIsIn(c[j], coordinateGroups)\n                    if (jPolygonIndex < 0) {\n                        coordinateGroups[iPolygonIndex].push(c[j])\n                    } else if (jPolygonIndex !== iPolygonIndex) {\n                        let newArr = coordinateGroups[iPolygonIndex].concat(coordinateGroups[jPolygonIndex])\n                        coordinateGroups.splice(iPolygonIndex, 1)\n                        coordinateGroups.splice(jPolygonIndex, 1)\n                        coordinateGroups.push(newArr)\n                        iPolygonIndex = coordinateGroups.length - 1\n                        jPolygonIndex = iPolygonIndex\n                    }\n                }\n            }\n        }\n    }\n    return coordinateGroups\n}\n\nfunction getCoordinatesInXY(coordinates) {\n    let coordinatesXY = []\n    coordinates.forEach(c => {\n        coordinatesXY.push({\n            x: c.location.lat,\n            y: c.location.lng\n        })\n    });\n    return coordinatesXY\n}\n\nfunction getXYCoordinatesInLatLng(coordinates) {\n    let coordinatesLatLng = []\n    coordinates.forEach(c => {\n        coordinatesLatLng.push({\n            lat: c.x,\n            lng: c.y\n        })\n    });\n    return coordinatesLatLng\n}\n\nfunction calculatePolygon(coordinates) {\n    let coordinatesXY = getCoordinatesInXY(coordinates)\n    // let polygonXY = convexhull.makeHull(coordinatesXY)\n    let polygonXY = concaveman(coordinatesXY)\n    let polygonLatLng = getXYCoordinatesInLatLng(polygonXY)\n    return polygonLatLng\n}\n\nfunction calculatePolygonsFromCoordinateGroups(coordinateGroups) {\n    let polygons = []\n    coordinateGroups.forEach(group => {\n        polygons.push(calculatePolygon(group))\n    });\n    return polygons\n}\n\nfunction getPolygon(coordinates, allowedDistance) {\n    let newCoordinates = JSON.parse(JSON.stringify(coordinates))\n    let groups = groupCoordinatesByDistance(newCoordinates, allowedDistance)\n    let polygons = calculatePolygonsFromCoordinateGroups(groups)\n    return polygons\n}\n\n\n\nfunction run(coordinates, allowedDistance) {\n    let coordinatesByTime = splitByTimestamp(coordinates)\n    let polygons = {}\n    for (let key in coordinatesByTime) {\n        polygons[key] = getPolygon(coordinatesByTime[key], allowedDistance)\n    }\n    return polygons\n}\n\nmodule.exports = run","require('dotenv').config()\nconst loadGoogleMapsApi = require('load-google-maps-api')\nlet fs = require('fs')\nlet polygons = require('./calculatePolygons')\n\nlet cords_full = fs.readFileSync('./assets/cords_full.json', 'utf8')\nlet one_coordinates = fs.readFileSync('./assets/chords_one.json', 'utf8')\nlet dataset_1 = JSON.parse(cords_full)\n\nlet searchRadiusButton = document.getElementById('searchRadius')\nlet map, googleMaps, heatmap\nlet radius = 50\n\n\n\nconst covertToGoogleMapsCords = (data) => {\n  return data.map((cord) => {\n    return {\n      location: new window.google.maps.LatLng({\n        lat: cord.location.lat,\n        lng: cord.location.lng,\n      }),\n      weight: cord.weight,\n    }\n  })\n}\n\n/* \nCreate map when DOM is loaded.\nSet up listener for adding new posotions to heatmap layer.\n*/\n\nconst initMap = function _initMap() {\n  document.addEventListener('DOMContentLoaded', () => {\n    let mapElement = document.getElementById('map')\n\n    loadGoogleMapsApi({\n      key: process.env.GOOGLE_MAPS_API_KEY,\n      libraries: ['visualization'],\n    }).then((google) => {\n      googleMaps = google\n\n      map = new googleMaps.Map(mapElement, {\n        center: {\n          lat: 56.657081713112085,\n          lng: 16.321899075213206,\n        },\n        zoom: 19,\n        zoomControl: false,\n        scaleControl: false,\n        scrollwheel: false,\n        disableDoubleClickZoom: true,\n        mapTypeId: 'satellite',\n      })\n\n      // Polygon-layer\n      createPolygonLayer(dataset_1)\n\n      // Circle-layer\n      let copyOfDataSet = [...dataset_1]\n      let colorizedDataset = divideColorToCordordinates(copyOfDataSet)\n      createCircelsLayer(colorizedDataset)\n\n      // Heatmap-layer  \n      createHeatmapLayer(covertToGoogleMapsCords(calculateWeight(dataset_1)))\n      writePositionsToJSONByClick()\n    })\n  })\n}\n\n\n/* \nCreate Polygon based on the given parameters. \n*/\n\nconst creatPolygon = (coordinates, sColor, sOpacity, weight, fColor, fOpacity) => {\n  let polygonLayer = new google.maps.Polygon({\n    paths: coordinates,\n    strokeColor: sColor,\n    strokeOpacity: sOpacity,\n    strokeWeight: weight,\n    fillColor: fColor,\n    fillOpacity: fOpacity,\n    draggable: false,\n\n  });\n\n  return polygonLayer\n}\n\n/* \nUses creatPolygon() to creates a new separate polygon for every array returned by polygons() method. \n*/\n\nconst createPolygonLayer = (coordinates) => {\n  let allCords = polygons(coordinates, 4)['10:00-10:59']\n  allCords.forEach(cordsArray => {\n    let polygon = creatPolygon(cordsArray, 'rgba(0, 0, 255, 1)', 1.2, 2, 'rgba(255, 0, 0, 1)', .85)\n    polygon.setMap(map);\n  });\n}\n\nconst createCircelsLayer = (coordinates) => {\n  coordinates.forEach(coordinates => {\n    for (let coord in coordinates) {\n      new window.google.maps.Circle({\n        strokeColor: '#FF0000',\n        strokeOpacity: 0.2,\n        strokeWeight: 2,\n        fillColor: coordinates[coord].color,\n        fillOpacity: 0.35,\n        map: map,\n        center: coordinates[coord].location,\n        radius: 2 // SÖKRADIE - TODO: fixa vettigt sökradie algorithm\n      });\n    }\n  });\n}\n\n/* \nCreate Heatmap-layer with coordinates array. \n*/\n\nconst createHeatmapLayer = (coordinates) => {\n\n  heatmap = new googleMaps.visualization.HeatmapLayer({\n    data: coordinates,\n  })\n\n  heatmap.setMap(map)\n\n  heatmap.set('radius', heatmap.get('radius') ? radius : radius)\n\n  let gradient = [\n    'rgba(0, 0, 255, 0)',\n    'rgba(0, 0, 255, 1)',\n    'rgba(55, 0, 200, 1)',\n    'rgba(125, 0, 120, 1)',\n    'rgba(200, 0, 55, 1)',\n    'rgba(255, 0, 0, 1)',\n  ]\n\n  heatmap.set('gradient', heatmap.get('gradient') ? null : gradient)\n\n}\n\n\n\nconst divideColorToCordordinates = (coordinates) => {\n\n  let dividedArray = splitToChunks(sortByTimestamp(coordinates), 6)\n\n  // TODO: snygga till dessa foreach till en nestad foreach\n  dividedArray[0].forEach(element => {\n    element.color = 'rgba(0, 0, 255, 0.5)'\n  });\n\n  dividedArray[1].forEach(element => {\n    element.color = 'rgba(0, 0, 255, 1)'\n  });\n\n  dividedArray[2].forEach(element => {\n    element.color = 'rgba(55, 0, 200, 1)'\n  });\n\n  dividedArray[3].forEach(element => {\n    element.color = 'rgba(125, 0, 120, 1)'\n  });\n\n  dividedArray[4].forEach(element => {\n    element.color = 'rgba(200, 0, 55, 1)'\n  });\n\n  dividedArray[5].forEach(element => {\n    element.color = 'rgba(255, 0, 0, 1)'\n  });\n\n  return dividedArray\n\n}\n\n\nconst splitToChunks = (array, parts) => {\n  let result = [];\n  for (let i = parts; i > 0; i--) {\n    result.push(array.splice(0, Math.ceil(array.length / i)));\n  }\n  return result;\n}\n\n\nconst calculateWeight = (stdCoordinates) => {\n  let crds = JSON.parse(JSON.stringify(stdCoordinates))\n  crds = sortByTimestamp(crds)\n\n  if (crds.length > 1) {\n    let diff = crds[crds.length - 1].timestamp - crds[0].timestamp\n    crds.forEach((element) => {\n      let percent = ((element.timestamp - crds[0].timestamp) / diff) * 100\n      element.weight = parseFloat(percent.toFixed(1)) + 1\n    })\n  }\n\n  return crds\n}\n\nconst changeRadius = () => {\n  searchRadiusButton.addEventListener('click', () => {\n    let inputValue = document.querySelector('.input').value\n    if (inputValue <= 100 && inputValue > 0) {\n      radius = inputValue\n      heatmap.set('radius', heatmap.get('radius') ? radius : radius)\n    }\n  })\n}\n\n/* \nAppends the \"click-positions\" longiture & latitude to the coordinates array.\n*/\n\nconst writePositionsToJSONByClick = () => {\n\n  googleMaps.event.addListener(map, 'click', (event) => {\n    arr.push({\n      location: new window.google.maps.LatLng({\n        lat: event.latLng.lat(),\n        lng: event.latLng.lng(),\n      }),\n      weight: 1,\n      timestamp: Date.now(),\n    })\n\n    heatmap.setMap(null)\n\n    createHeatmapLayer(covertToGoogleMapsCords(calculateWeight(arr)))\n  })\n}\n\n\nconst sortByTimestamp = (coordinates) => {\n  return coordinates.sort(function (a, b) {\n    return a.timestamp - b.timestamp\n  })\n}\n\ninitMap()\nchangeRadius()\n"]}